<!DOCTYPE html>
<html lang="en">
<head>
  <title>Bootstrap Example</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=merriweather">
      <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Rancho&effect=fire-animation">
        <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Rancho&effect=shadow-multiple|3d">
          <style>
            .must_hide {
              display: none !important;
            }
          </style>
</head>
<body>

 <img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpics.clipartpng.com%2Fmidle%2FPawn_White_Chess_Piece_PNG_Clip_Art-2751.png&f=1&nofb=1&ipt=686de2f1f2205ba0aa52a662ebd184b4b2e3f6de297c21add3740968d5b7bf2c&ipo=images" height="50" id="whiteSolder">
  <img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftoppng.com%2Fuploads%2Fthumbnail%2Fpawn-black-chess-piece-11532856202krihsmphdp.png&f=1&nofb=1&ipt=2bc3cbcc0c47b93dfb58aea0dca3a5f187cdcd3711ad3cd4842e3211a66eae7a&ipo=images" height="50" id="blackSolder">
   <img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpics.clipartpng.com%2FRook_White_Chess_Piece_PNG_Clip_Art-2754.png&f=1&nofb=1&ipt=40fbc49844b2df9922012b8e6c8a5b397b10a59530c1ece7bd5d835b355f8b6a&ipo=images" height="50" id="whiteRook">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fclipground.com%2Fimages%2Fchess-rook-clipart-6.png&f=1&nofb=1&ipt=3e3d33f4675f2e741961179e67762d9f322fb984aa32b47edd2d54b72917ed13&ipo=images" height="50" id="blackRook">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwebstockreview.net%2Fimages%2Fchess-clipart-svg-4.png&f=1&nofb=1&ipt=cecf360d4a6c1d60f0c8a2c9e6ad3f08f353a95d503dafa9f770f5d5b31c197e&ipo=images" height="50" id="blackElephant">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fimages.vexels.com%2Fmedia%2Fusers%2F3%2F254456%2Fisolated%2Fpreview%2Fd7a2f9afd47dbefcccd32dbae2f6a576-white-queen-chess-piece-color-stroke.png&f=1&nofb=1&ipt=923c5e3482b706fbde7069c254014ad78473f51cc779b4d7d7db68c8541839ef&ipo=images" height="50" id="whiteElephant">


<img src="https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fwww.geocities.ws%2Fismael%2Fwhite_horse.png&f=1&nofb=1&ipt=a39aed5baf99e8e1b191382b64abdfc8832ec15b98f49f317b4847e574da40a5&ipo=images" height="50" id="whiteHourse">


<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fclipartspub.com%2Fimages%2Fchess-pieces-clipart-knight-3.png&f=1&nofb=1&ipt=80568e167a9650e199226e49b48e749bae11b9db2f1c8b0e0fd33fcb3047bfe5&ipo=images" height="50" id="blackHourse">


<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fi.pinimg.com%2Foriginals%2F9b%2Fa0%2F27%2F9ba0277979c424fdb498efb66a7b140c.png&f=1&nofb=1&ipt=b919eadbb663c7e71fa621904674e4e951acb0761b4860d5a486d3cdab9177b8&ipo=images" height="50" id="blackQueen">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpics.clipartpng.com%2FQueen_White_Chess_Piece_PNG_Clip_Art-2757.png&f=1&nofb=1&ipt=15df4d77bddbe7d5c8f7eacf4b55df5c10b859780b4acb9e369f7fc49f87a09c&ipo=images" height="50" id="whiteQueen">


<img src="https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fcdn.shopify.com%2Fs%2Ffiles%2F1%2F2209%2F1363%2Fproducts%2Fadditional_megachess-44_33afb3f4-7bfe-4438-a46a-46b5d1b35078_1200x1200.png%3Fv%3D1535649501&f=1&nofb=1&ipt=09d270b3980618fd491cf36c7c524ac2072c82eee1d11d5cbc25fec7f1b438f0&ipo=images" height="50" id="blackKing">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpics.clipartpng.com%2FQueen_White_Chess_Piece_PNG_Clip_Art-2757.png&f=1&nofb=1&ipt=15df4d77bddbe7d5c8f7eacf4b55df5c10b859780b4acb9e369f7fc49f87a09c&ipo=images" height="50" id="whiteKing" />

<audio src="https://github.com/MahmoudHegazi/simple_chess_js/raw/main/sound1_wrong.mp3" style="display:none !important;" id="wrong_sound" ></audio>


<div class="container-fluid">
    <div id="final_message" style="position: absolute;top: 0;left: 0;z-index: 100;width:100%;" class="d-flex jusitfy-content-center must_hide">
        <img id="win_image" src="https://media1.giphy.com/media/jsGz81YPCgw9YSliV0/giphy.gif" style="width:100%;" class="must_hide">
    </div>
    <div class="text-center" style="display:none;" id="main_error">
    </div>
    <div class="p-3 bg-dark mx-auto rounded d-flex justify-content-center align-items-center text-center" style="overflow:auto;background: chocolate;border: 4px solid chocolate;">
        <h1 class="font-effect-fire-animation" style="letter-spacing: 0.120rem;font-family: cursive;padding-top:7px;">multipleChess.com</h1>
    </div>
    <div class="bg-dark mx-auto rounded text-center" style="overflow:auto;max-height:780px;min-height:880px;border: 4px solid chocolate;">
        <div>
          <div class="text-left p-2">
             <button id="messageDisplayer" class="btn btn-outline-light" href="#playersMessages" data-toggle="collapse">Show Message</button>
          </div>
          <div class="container-fluid p-1 collapse" id="playersMessages"  style="box-shadow: rgb(0 0 0) 6px 4px 10px 0px, rgba(227, 229, 220, 0.94) 4px 6px 20px 0px;">
          </div>
        </div>
        <canvas class="rounded border" id="demo" width="640" height="700">
            Your browser does not support the HTML canvas tag.
        </canvas>
        <div id="game_hiddens" class="container p-3 must_hide">
            <div id="client_error" class="must_hide">
            </div>
            <div id="screenConts" class="must_hide container-fluid w-100 p-0 border-rounded d-flex justify-content-center align-items-start" style="box-shadow: 6px 4px 10px 0 rgb(217 160 74), 4px 6px 20px 0 rgb(227 229 220 / 94%);max-width: 610px;display:none;">
                <img id="hourse_move_video" src="https://media0.giphy.com/media/wKdJy5gnLDb7ILmBu9/giphy.gif?cid=790b7611c7vhznfx69mvdleyy5ia10nvwtu43h7twlv6oh2y&ep=v1_gifs_search&rid=giphy.gif&ct=g" style="width:100%;object-fit:contain;max-width: 600px;" style="width:100%;display:none;" />
            </div>
        </div><!-- https://i.giphy.com/wKdJy5gnLDb7ILmBu9.webp -->
    </div>
</div>
<div>
</div>



<script>




// gameMessage
let environment = 'development';
class GameError {
        constructor(isSystem = false, errorMsg = "Unknown error", caller = 'Uknown', error = null, game = null, errorCb = () => {})
        {
                try {
                
                        this.message = errorMsg ? errorMsg : 'Unknown error';
                        //development
                        this.environment = 'publish';
                        this.isError = true;
                        this.bsStatus = 'danger';
                        this.bsStrong = 'Error: ';
                        this.error = error;
                        this.errorCb = errorCb;
                        this.messageHTML = false;
                        this.isSystem = isSystem;
                        this.game = game;
                        this.canvasElm = $("canvas#demo");
                        this.messageElm = $("#client_error");
                        this.gameHiddens = $("#game_hiddens");
                        this.isJSError = (typeof(this.error) === 'object' && this.error instanceof Error && this.error.message) ? true : false;
                        if (environment === 'publish') {
                                if (this.isJSError || this.isSystem) {
                                        this.message = 'Game System Error!';
                                }
                        } else {
                                if (this.isJSError) {
                                        this.message = this.error.message;
                                }
                        }
                        if (this.messageElm.length && this.canvasElm.length && this.messageElm.length && this.gameHiddens.length) {
                                this.messageHTML = true;
                        }
                } catch (error) {
                        game = game ? game : null;
                        return new ClientError(true, "Unknown error while constructoring GameError", 'GameError.constructor', error, game);
                }
        }
        htmlErrorStart(errorHTML = '', message = null) {
                try {
                        if (errorHTML && this.messageHTML === true && (this.bsStatus && typeof(this.bsStatus) === 'string') && (this.bsStrong && typeof(this.bsStrong) === 'string')) {
                                this.canvasElm.hide();
                                this.messageElm.removeClass("must_hide");
                                this.messageElm.html(errorHTML);
                                this.gameHiddens.removeClass("must_hide");
                        } else {
                                alert(this.message);
                        }
                } catch (error) {
                        console.log('unknown error from GameError.htmlErrorStart', error);
                }
        }
        isValidErrorMsg() {
                return this.message && typeof(this.message) === 'string';
        }
        isValidError() {
                return this.error && typeof(this.error) === 'object' && this.error instanceof Error;
        }
        hideError() {
                try {
                        this.messageElm.addClass("must_hide");
                        this.gameHiddens.addClass("must_hide");
                        this.canvasElm.show();
                } catch (error) {
                        console.log('unknown error from GameError.hideError', error);
                }
        }
        throw () {
                throw 'System Error!';
        }
}
class ClientError extends GameError {
        constructor(isSystemMsg = false, errorMsg = "Unknown error", caller = 'Uknown', error = null, game = null, errorCb = () => {}) {
                const privateErrorCb = (typeof(errorCb) === 'function') ? errorCb : () => {};
                const privateCaller = (caller && typeof(caller) === 'string') ? caller : 'unknown method';
                // call the super class constructor and pass in the name parameter
                super(isSystemMsg, errorMsg, caller, error, game, errorCb);
                this.display = this.displayError();
        }
        getErrorTemplate() {
                return `
              <div class="alert alert-${this.bsStatus} alert-dismissible">
                    <button type="button" class="close" data-dismiss="alert">&times;</button>
                    <strong>${this.bsStrong}!</strong> ${this.message}
              </div>
                `;
        }
        displayError(errorCb) {
                try {
                        if (this.isValidErrorMsg()) {
                                this.htmlErrorStart(this.getErrorTemplate(), null);
                        }
                        if (this.isValidError()) {
                                console.log(`error from ${this.caller}`, this.error);
                        }
                        /* optinal after error callback */
                        if (typeof(this.errorCb) === 'function') {
                                try {
                                        return this.errorCb();
                                } catch (error) {
                                        console.log('unknown error from Calling the errorCb callback', error);
                                }
                        }
                } catch (error) {
                        console.log('unknown error from GameError.displayError', error);
                }
                return false;
        }
}
class Character {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                this.img = img;
                this.sWidth = sWidth;
                this.sHeight = sHeight;
                this.square = square;
                this.sx = this.square.sx;
                this.sy = this.square.sy;
                this.ctx = ctx;
                this.game = game;
                this.width = (this.sWidth / 2);
                this.height = (this.sHeight / 1.5) + 2;
                // size of square - size of image
                this.remanierX = (this.sWidth - this.width);
                this.remanierY = (this.sHeight - this.height);
                // remaning/2 == (center) height and center width align-items-center justinfy-content-center (can have all)
                this.x = this.cascadeX();
                this.y = this.cascadeY();
                this.fullX = this.x + this.width;
                this.fullY = this.y + this.height;
                this.draw(false);
        }
        /* cascade on update relationship in js as sqlalchemy */
        cascadeX() {
                return Math.max((this.remanierX / 2), 0) + this.square.sx;
        }
        cascadeY() {
                return Math.max((this.remanierY / 2), 0) + this.square.sy;
        }
        draw(isUpdate = true) {
                //this.ctx.beginPath();
                if (isUpdate) {
                        /* clear old before draw if it update square also dynamic in kills replace*/
                        this.square.empty();
                }
                this.ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
                // this method achive best performance nothing more than needed. 
        }
        clearRect() {
                this.ctx.beginPath();
                this.ctx.clearRect(this.x, this.y, this.fullX, this.fullY);
                this.ctx.rect(this.x, this.y, this.fullX, this.fullY);
                this.ctx.fillStyle = this.color;
                this.ctx.fill();
                return true;
        }
        displayMovement(moveId, charClass) {
                if (moveId && $(`#${moveId}`).length && typeof(charClass) === 'object' && charClass instanceof this) {
                        alert('hi yes');
                } else {
                        alert("throw error invalid movment to typescript smuilate and testing client side while using the game.");
                }
        }
}
class Black extends Character {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
                this.id = 1;
                this.winner = false;
                this.moves = 0;
                //socket related (setup onConnect event)
                this.ready = true;
                this.lastPlayTime = null;
                this.ready = true;
                this.kills = [];
                // user data
                this.color = 'khaki';
                this.name = 'unknown 1';
        }
        /* All squares Black Character can not Move in */
        getReds(targets) {
                try {
                        const redTargets = [];
                        for (let s = 0; s < targets.length; s++) {
                                const square = targets[s];
                                if (typeof(square.holder) === 'object' && square.holder instanceof Black) {
                                        redTargets.push(square);
                                        console.log("there are ally stand here");
                                }
                        }
                        return redTargets;
                } catch (error) {
                        return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
                }
        }
        /* All squares Black Character can Move in */
        getGreens(targets) {
                try {
                        const greenTargets = [];
                        for (let s = 0; s < targets.length; s++) {
                                const square = targets[s];
                                if (!((typeof(square.holder) === 'object' && square.holder instanceof Black))) {
                                        greenTargets.push(square);
                                        console.log("there its empty or enemy stand here");
                                }
                        }
                        return greenTargets;
                } catch (error) {
                        return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
                }
        }
        /* All squares White Character (enemy) stand on it */
        getTargets(targets) {
                try {
                        const redTargets = [];
                        for (let s = 0; s < targets.length; s++) {
                                const square = targets[s];
                                if ((typeof(square.holder) === 'object' && square.holder instanceof White)) {
                                        redTargets.push(square);
                                        console.log("there its empty or enemy stand here");
                                }
                        }
                        return redTargets;
                } catch (error) {
                        return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
                }
        }
        /* used by bot / and begniner helight mode i like this mode myself (called also random play helped by OOP and Math and 2D Array */
        getMoveOptions(square) {
                const allowedSquares = this.getAll(square);
                const reds = this.getReds(allowedSquares);
                const greens = this.getGreens(allowedSquares);
                const killOptions = this.getTargets(allowedSquares);
                console.log('allowedSquares', allowedSquares);
                console.log('ally', reds);
                reds.forEach((greenSquare) => {
                        greenSquare.color = 'green';
                });
                this.game.setupSquares();
                console.log('enemies', greens);
                console.log('kill Options', killOptions);
                return {
                        allowedSquares,
                        reds,
                        greens,
                        killOptions
                };
        }
}
class White extends Character {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
                this.id = 2;
                this.moves = 0;
                //socket related (setup onConnect event)
                this.ready = true;
                this.winner = false;
                this.lastPlayTime = null;
                this.someThingCalledDraw = false;
                this.kills = [];
                // user data
                this.color = 'white';
                this.name = 'unknown 2';
        }
        /* All squares White Character can not Move in */
        getReds(targets) {
                try {
                        const redTargets = [];
                        for (let s = 0; s < targets.length; s++) {
                                const square = targets[s];
                                if (typeof(square.holder) === 'object' && square.holder instanceof White) {
                                        redTargets.push(square);
                                        console.log("there are ally stand here");
                                }
                        }
                        return redTargets;
                } catch (error) {
                        return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
                }
        }
        /* All squares White Character can Move in */
        getGreens(targets) {
                try {
                        const greenTargets = [];
                        for (let s = 0; s < targets.length; s++) {
                                const square = targets[s];
                                if (!(typeof(square.holder) === 'object' && square.holder instanceof White)) {
                                        greenTargets.push(square);
                                        console.log("there its empty or enemy stand here");
                                }
                        }
                        return greenTargets;
                } catch (error) {
                        return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
                }
        }
        /* All squares Black Character (enemy) stand on it */
        getTargets(targets) {
                try {
                        const redTargets = [];
                        for (let s = 0; s < targets.length; s++) {
                                const square = targets[s];
                                if ((typeof(square.holder) === 'object' && square.holder instanceof Black)) {
                                        redTargets.push(square);
                                        console.log("there its empty or enemy stand here");
                                }
                        }
                        return redTargets;
                } catch (error) {
                        return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
                }
        }
}
// this classes will dynamic extends one of 2 classes black or white
class B_Solider extends Black {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
}
class B_King extends Black {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
        rightOne(square, check) {
                return (square.i < 8) && (square.i + 1 === check.i) && (square.r === check.r);
        }
        leftOne(square, check) {
                return (square.i > 0) && (square.i - 1 === check.i) && (square.r === check.r);
        }
        forwardOne(square, check) {
                return (square.r < 8) && (square.r + 1 === check.r) && (square.i === check.i);
        }
        backOne(square, check) {
                return (square.r > 0) && (square.r - 1 === check.r) && (square.i === check.i);
        }
        diagonallyForawrdRightOne(square, check) {
                return (square.r < 8) && (square.i < 8) &&
                        ((square.r + 1) === check.r) && ((square.i + 1) === check.i);
        }
        diagonallyForawrdLeftOne(square, check) {
                return (square.r < 8) && (square.i > 0) &&
                        ((square.r + 1) === check.r) && ((square.i - 1) === check.i);
        }
        diagonallyBackRightOne(square, check) {
                return (square.r > 0) && (square.i < 8) &&
                        ((square.r - 1) === check.r) && ((square.i + 1) === check.i);
        }
        diagonallyBackLeftOne(square, check) {
                return (square.r > 0) && (square.i > 0) &&
                        ((square.r - 1) === check.r) && ((square.i - 1) === check.i);
        }
        getAll(square) {
                try {
                        /* king can move around 3row between, 3cols right and 3 cols left */
                        const targets = [];
                        for (let r = 0; r < this.game.squares.length; r++) {
                                const rowArr = this.game.squares[r];
                                for (let c = 0; c < rowArr.length; c++) {
                                        const check = rowArr[c];
                                        if (this.rightOne(square, check)) {
                                                targets.push(check);
                                        } else if (this.leftOne(square, check)) {
                                                targets.push(check);
                                        } else if (this.forwardOne(square, check)) {
                                                targets.push(check);
                                        } else if (this.backOne(square, check)) {
                                                targets.push(check);
                                        } else if (this.diagonallyForawrdRightOne(square, check)) {
                                                targets.push(check);
                                        } else if (this.diagonallyForawrdLeftOne(square, check)) {
                                                targets.push(check);
                                        } else if (this.diagonallyBackRightOne(square, check)) {
                                                targets.push(check);
                                        } else if (this.diagonallyBackLeftOne(square, check)) {
                                                targets.push(check);
                                        } else {
                                                continue;
                                        }
                                }
                        }
                        return targets;
                } catch (error) {
                        return new ClientError(true, "Unknown error", 'B_King.getAll', error, this);
                }
        }
}
class B_Queen extends Black {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
}
class B_Hourse extends Black {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
                this.move = '#black_hourse_move';
                this.attack = '';
        }
}
class B_Alfil extends Black {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
}
class B_Rook extends Black {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
}
class W_Solider extends White {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
}
class W_King extends White {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
}
class W_Queen extends White {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
}
class W_Hourse extends White {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
                this.move = '#black_hourse_move';
                this.attack = '';
        }
}
class W_Alfil extends White {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
}
class W_Rook extends White {
        constructor(img, square, sWidth, sHeight, ctx, game) {
                super(img, square, sWidth, sHeight, ctx, game);
        }
}
class Square {
        constructor(id, db_id, r, i, color, sx, sy, sWidth, sHeight, ctx, game) {
                this.id = id;
                this.db_id = db_id;
                this.i = i;
                this.r = r;
                this.color = color;
                this.sx = sx;
                this.sy = sy;
                this.width = sWidth;
                this.height = sHeight;
                this.fullX = this.sx + this.width;
                this.fullY = this.sy + this.height;
                this.ctx = ctx;
                this.color = color;
                this.defaultColor = color;
                this.lineWidth = String(game.lineWidth);
                this.strokeStyle = game.strokeStyle;
                /* for clear why say css and border-box contains */
                this.borderTop = game.lineWidth;
                this.borderBottom = game.lineWidth;
                this.borderRight = game.lineWidth;
                this.borderLeft = game.lineWidth;
                this.holder = null;
                // sqlalchemy like relation, one to many, game has many squares. core
                this.game = game;
                this.draw();
        }
        setHolder(piece) {
                this.holder = piece;
        }
        draw() {
                this.ctx.beginPath();
                /* this inhirted from css, border 1px right, left, top, bottom border included within the element size
                 */
                this.ctx.rect(
                        this.sx + this.borderLeft, this.sy + this.borderTop, this.width - this.borderRight, this.height - this.borderBottom
                );
                this.ctx.lineWidth = this.lineWidth;
                this.ctx.strokeStyle = this.strokeStyle;
                this.ctx.stroke();
                this.ctx.fillStyle = this.color;
                this.ctx.fill();
                return true;
        }
        changeColor(color = null) {
                this.color = typeof(color) === 'string' ? color : this.defaultColor;
                this.draw();
                if (this.holder instanceof Character) {
                        this.holder.draw();
                }
        }
        clearRect() {
                return this.ctx.clearRect(this.x, this.y, this.fullX, this.fullY);
        }
        empty() {
                this.clearRect();
                this.draw();
                return true;
        }
        /* as this responsive desgin canvas must get dynamic x,y,h,w */
        getX() {
                let x = null;
                const squareWidth = this.width;
                if (!isNaN(parseInt(squareWidth)) && !isNaN(parseInt(this.i))) {
                        // 7 considered gab or margin or test
                        x = (squareWidth * this.i);
                } else {
                        console.log("invalid square size data from Square.getX");
                }
                return x;
        }
        getY() {
                let y = null;
                const squareHeight = this.height;
                if (!isNaN(parseInt(squareHeight)) && !isNaN(parseInt(this.r))) {
                        y = squareHeight * this.r;
                } else {
                        console.log("invalid square size data from Square.getY");
                }
                return y;
        }
        //click() {}
}
class ClientMessage {
    constructor(turnClass, color='white', bg='black') {
       try {
           this.turnClass = turnClass;
           this.messageElm = this.turnClass;
           this.color = color;
           this.bg = bg;

       } catch (error) {
           return new ClientError(true, error.message, 'ClientMessage.constructor', error, null);
       }
    }
    
    get messageElm() {
       return this._messageElm;
    }
    set messageElm(turnClass) {
      try {
        let messageElm = null;
        
        if (
          typeof(turnClass) === 'function' && turnClass.name){
          messageElm = turnClass.name.trim().toLowerCase();
        } 
        if (!messageElm && typeof(turnClass) === 'function' && turnClass.constructor && turnClass.constructor.name) {
          messageElm = turnClass.prototype.constructor.name.trim().toLowerCase();
        }
        
        if (messageElm && $(`#${messageElm}`).length) {
           this._messageElm = $(`#${messageElm}`);
           this.bg = messageElm;
        } else {
           this._messageElm = null;
        }
        
      } catch (error) {
        this._messageElm = null;
        return new ClientError(true, error.message, 'ClientMessage.messageElm', error, this);
      }
    }
    

}

class ClientSoundMessage extends ClientMessage {
   constructor(turnClass, soundElm, message='', status='danger', color='white', bg='black') {

        if (turnClass.prototype instanceof Character && soundElm && soundElm.nodeName && soundElm.nodeName.toLowerCase() === 'audio') {

          super(turnClass, color, bg);
          this.audioElm = soundElm;
          this.playAudio();
          this.displayMessage(message, status);
        } else {
          return new ClientError(true, 'invalid audio element provided', 'constructor', null, null);
        }

   }
   playAudio() {
     try {
         if (this.audioElm && this.audioElm.nodeName && this.audioElm.nodeName.toLowerCase() === 'audio'){
           if (this.audioElm.paused){
             // always start sound from begning
             this.audioElm.currentTime = 0;
             this.audioElm.play();
           } else {
             this.audioElm.pause();
             this.audioElm.currentTime = 0;
             this.audioElm.play();
           }
         } else {
         
           return new ClientError(true, 'Invalid Sound Element', 'ClientSoundMessage.constructor', null, this);
         }
     } catch (error) {
         return new ClientError(true, error.message, 'ClientSoundMessage.playAudio', null, this);
     }
   }
   displayMessage(message='', status='danger') {
      try {
          if (message) {
             
             if (this.color === this.bg) {
                // must one we not know 1 and it one color
                if (this.color === 'green') {
                  this.color = 'white';
                }  else {
                  this.color = 'green';
                }
             }
             this.messageElm.html(`
              <div class="alert alert-dismissible" style="color:${this.color};background:${this.bg}">
                  <button type="button" class="close" data-dismiss="alert">&times;</button>
                  <div class="text-left">
                    <strong>System:</strong> ${message}
                  </div>
              </div>
             `);
          } else {
              this.messageElm.html('');
          }
          return true;
      } catch (error) {
          return new ClientError(true, error.message, 'ClientSoundMessage.displayMessage', error, this);
      
      }
   }
   
   
}


//GameError
class Game {
        constructor(cElm, errorElm, imagesIds = [], soundsIds = []) {
                try {
                
               
                
                
                        if (cElm && $(cElm).length && errorElm && $(errorElm).length && Array.isArray(imagesIds) &&
                                Array.isArray(soundsIds)) {
                                this.imagesIds = imagesIds;
                                this.soundsIds = soundsIds;
                                this.images = {};
                                this.sounds = {};
                                this.squares = [];
                                this.messageParent = $("#playersMessages");
                                this.messagesToggler = $("#messageDisplayer");
                                this.messageDisplayed = false;
                                this.messageElements = [];
                                this.cJquery = $(cElm);
                                this.canvas = this.cJquery.get(0);
                                this.context = this.canvas.getContext("2d");
                                this.boardContext = this.canvas.getContext("2d");
                                this.turnlist = ['black', 'white'];
                                this.turnClasses = [Black, White];
                                /* for random selected who white and who black use this or others also can used for order as list black always first , white second, nasa third etc */
                                //this.turn = this.turnlist[Math.floor(Math.random() * this.turnlist.length)];
                                
                                //new ClientSoundMessage(null, sounds['wrong_sound']);
                                /* for pre selected who white and who black use this */
                                this.turn = 'black';

                                this.setup = false;
                                this.maxImages = 14;
                                this.maxSounds = 1;
                                this.imagesReady = this.setupImages();
                                this.soundsReady = this.setupSounds();
                                this.row = 0;
                                this.col = 0;
                                this.maxRow = 8;
                                this.maxCol = 8;
                                this.lineWidth = 1;
                                this.strokeStyle = 'lightgray';
                                this.sWidth = 80;
                                this.sHeight = 100;
                                this.lastSquareColor = 'white';
                                this.guideOn = true;
                                this.iNoob = true;
                                this.classes = [
                                        Game,
                                        Character,
                                        Black,
                                        White,
                                        Square,
                                        ClientMessage,
                                        ClientError,
                                        Square,
                                        B_Rook,
                                        B_Hourse,
                                        B_Alfil,
                                        B_Queen,
                                        B_King,
                                        B_Solider,
                                        W_Solider,
                                        W_Rook,
                                        W_Hourse,
                                        W_Alfil,
                                        W_Queen,
                                        W_King
                                ];
                                this.turnClass = this.classByName(this.turn);

                                

                                // relation 
                                this.Childs = [];
                                const blackSolder = this.images['blackSolder'];
                                const blackQueen = this.images['blackQueen'];
                                const blackRook = this.images['blackRook'];
                                const blackHourse = this.images['blackHourse'];
                                const blackElephant = this.images['blackElephant'];
                                const blackKing = this.images['blackKing'];
                                const whiteSolder = this.images['whiteSolder'];
                                const whiteQueen = this.images['whiteQueen'];
                                const whiteRook = this.images['whiteRook'];
                                const whiteHourse = this.images['whiteHourse'];
                                const whiteElephant = this.images['whiteElephant'];
                                const whiteKing = this.images['whiteKing'];                     
                                
                                // this charactersIndexes can not set has no setter
                                this.charactersIndexes = null;
 
                                /* Load Private Start */
                                const load = () => {
                                        if (this.setupClientMessages()){
                                            if (this.soundsReady) {
                                                    if (this.imagesReady) {
                                                            //this.context.globalCompositeOperation = 'destination-over';
                                                            this.draw();
                                                            console.log('squares', this.squares);
                                                            if (this.squares.length === 8) {
                                                                    // events and logic of game
                                                                    this.BeforeMoveOn();
                                                                    return true;
                                                            } else {
                                                                    return new ClientError(true, "Error Unable to setup squares", 'Game.constructor', null, this);
                                                            }
                                                    } else {
                                                            return new ClientError(true, "Error  invalid images provided", 'Game.constructor', null, this);
                                                    }
                                            } else {
                                                    return new ClientError(true, "Error invalid sounds provided", 'Game.constructor', null, this);
                                            }
                                        } else {
                                           return new ClientError(true, "Unable To Setup ClientMessages", 'Game.constructor', null, this);
                                        }

                                };
                                this.setup = load();
                        } else {
                                return new ClientError(true, "Error Canvas not constructed successfully", 'Game.constructor', null, this);
                        }
                } catch (error) {
                
                        //console.log('error from game.constructor', error);
                        return new ClientError(true, error.message, 'Game.constructor', error, this);
                }
        }
        onToggleMessage(e) {

            if (this.messagesToggler.text() == 'Show Message') {
               this.messagesToggler.text('Hide Message');
               this.messagesToggler.removeClass('btn-outline-light');
               this.messagesToggler.addClass('btn-outline-danger');
               this.messageDisplayed = true;
            } else {
               this.messagesToggler.text('Show Message');
               this.messagesToggler.removeClass('btn-outline-danger');
               this.messagesToggler.addClass('btn-outline-light');
               this.messageDisplayed = false;
            }
        }
        get winner() {
                return true;
        }
        get charactersIndexes() {
              return this._charactersIndexes;
        }
        set charactersIndexes(charIndexes){
             try {
             
                  const resultCharIndexes = [];
                  let validCharIndex = true;
                  
                  if (charIndexes && Array.isArray(charIndexes) && charIndexes.length === 8 ) {
                       
                       let maxPieces = 32;
                       let breakLoop = false;
                       for (let v=0; v<charIndexes.length; v++) {
                          if (breakLoop){
                              break;
                          }
                          const charIndexArr = charIndexes[v];
                          if (Array.isArray(charIndexArr) && charIndexArr.length === 8) {
                            for (let vc=0; vc<charIndexArr.length; vc++) {
                                 const charIndexOb = charIndexArr[vc];
                                 if (
                                       !charIndexOb || (typeof(charIndexOb) === 'objec' && charIndexOb.hasOwnProperty('db_id') &&
                                       charIndexOb.hasOwnProperty('img')  && charIndexOb.hasOwnProperty('Class') &&
                                       charIndexOb.hasOwnProperty('r')  && charIndexOb.hasOwnProperty('c') &&
                                       charIndexOb.hasOwnProperty('color'))
                                       
                                       ) {
                                       let newCharIndexObj = null;
                                       if (charIndexOb) {
                                           // square that stand on it pieeace
                                           newCharIndexObj = {
                                              db_id: charIndexOb.db_id,
                                              img: this.images[charIndexOb.img],
                                              Class: this.classByName(charIndexOb.Class),
                                              r: charIndexOb.r,
                                              c: charIndexOb.c,
                                              color: charIndexOb.color
                                           }
                                       } else {
                                           // empty square
                                           newCharIndexObj = null;
                                       }
                                       
                                       if (maxPieces < 0) {
                                          return new ClientError(true, 'Invalid pieces Found', 'Game.setcharactersIndexes', null, this);
             
                                       }
                                       charIndexArr.push(newCharIndexObj);
             
                                 } else {
                                    // found invalid object
                                    return new ClientError(true, 'Invalid pieces Found', 'Game.setcharactersIndexes', null, this);
                                 }
                                 if (charIndexArr.length === 8) {
                                    resultCharIndexes.push(charIndexArr);
                                 } else {
                                    return new ClientError(true, 'Invalid count of charactersIndexes nested row array', 'Game.setcharactersIndexes', null, this);
                                 }
                                 
                            }
                          }
                       }
                       
                       this._charactersIndexes = charactersIndexes;
                  } else {
                       this._charactersIndexes = [       
                             [
                                 {db_id: 1,img: this.images['blackRook'],      Class: this.classByName('B_Rook'), r: 0, c: 0,  color: 'black'},
                                 {db_id: 2,img: this.images['blackHourse'],    Class: this.classByName('B_Hourse'),     r: 0, c: 1,  color: 'black'},
                                 {db_id: 3,img: this.images['blackElephant'],  Class: this.classByName('B_Alfil'),      r: 0, c: 2,  color: 'black'},
                                 {db_id: 4,img: this.images['blackQueen'],     Class: this.classByName('B_Queen'),      r: 0, c: 3,  color: 'black'},
                                 {db_id: 5,img: this.images['blackKing'],      Class: this.classByName('B_King'),       r: 2, c:2,  color: 'black'},
                                 {db_id: 6,img: this.images['blackElephant'],  Class: this.classByName('B_Alfil'),      r: 0, c: 5,  color: 'black'},
                                 {db_id: 7,img: this.images['blackHourse'],    Class: this.classByName('B_Hourse'),     r: 0, c: 6,  color: 'black'},
                                 {db_id: 8,img: this.images['blackRook'],      Class: this.classByName('B_Rook'),       r: 0, c: 7,  color: 'black'}
                             ],
                             [
                                 /* row 2 */
                                 {db_id: 9, img: this.images['blackSolder'],    Class:  this.classByName('B_Solider'),    r: 1, c: 0,  color: 'black'},
                                 {db_id: 10,img: this.images['blackSolder'],    Class: this.classByName('B_Solider'),    r: 1, c: 1,  color: 'black'},
                                 {db_id: 11,img: this.images['blackSolder'],    Class: this.classByName('B_Solider'),    r: 1, c: 2,  color: 'black'},
                                 {db_id: 12,img: this.images['blackSolder'],    Class: this.classByName('B_Solider'),    r: 1, c: 3,  color: 'black'},
                                 {db_id: 13,img: this.images['blackSolder'],    Class: this.classByName('B_Solider'),    r: 1, c: 4,  color: 'black'},
                                 {db_id: 14,img: this.images['blackSolder'],    Class: this.classByName('B_Solider'),    r: 1, c: 5,  color: 'black'},
                                 {db_id: 15,img: this.images['blackSolder'],    Class: this.classByName('B_Solider'),    r: 1, c: 6,  color: 'black'},
                                 {db_id: 16,img: this.images['blackSolder'],    Class: this.classByName('B_Solider'),    r: 1, c: 7,  color: 'black'}
                             ],
                             [
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                             ],
                             [
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,              
                             ],
                             [
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,              
                             ],
                             [
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,
                                 null,              
                             ],
             
                             [   
                                 {db_id: 17,img: this.images['whiteSolder'],   Class: this.classByName('W_Solider'),    r: 6, c: 0,  color: 'white'},
                                 {db_id: 18,img: this.images['whiteSolder'],   Class: this.classByName('W_Solider'),    r: 6, c: 1,  color: 'white'},
                                 {db_id: 29,img: this.images['whiteSolder'],   Class: this.classByName('W_Solider'),    r: 6, c: 2,  color: 'white'},
                                 {db_id: 20,img: this.images['whiteSolder'],   Class: this.classByName('W_Solider'),    r: 6, c: 3,  color: 'white'},
                                 {db_id: 21,img: this.images['whiteSolder'],   Class: this.classByName('W_Solider'),    r: 6, c: 4,  color: 'white'},
                                 {db_id: 22,img: this.images['whiteSolder'],   Class: this.classByName('W_Solider'),    r: 6, c: 5,  color: 'white'},
                                 {db_id: 23,img: this.images['whiteSolder'],   Class: this.classByName('W_Solider'),    r: 6, c: 6,  color: 'white'},
                                 {db_id: 24,img: this.images['whiteSolder'],   Class: this.classByName('W_Solider'),    r: 6, c: 7,  color: 'white'}
                             ],
             
             
                             [   /* row  8 */
                                 {db_id: 26,img: whiteRook,     Class: this.classByName('W_Rook'),       r: 7, c: 0,  color: 'white'},
                                 {db_id: 27,img: whiteHourse,   Class: this.classByName('W_Hourse'),     r: 7, c: 1,  color: 'white'},
                                 {db_id: 28,img: whiteElephant, Class: this.classByName('W_Alfil'),      r: 7, c: 2,  color: 'white'},
                                 {db_id: 29,img: whiteQueen,    Class: this.classByName('W_Queen'),      r: 7, c: 3,  color: 'white'},
                                 {db_id: 30,img: whiteKing,     Class: this.classByName('W_King'),       r: 7, c: 4,  color: 'white'},
                                 {db_id: 31,img: whiteElephant, Class: this.classByName('W_Alfil'),      r: 7, c: 5,  color: 'white'},
                                 {db_id: 32,img: whiteHourse,   Class: this.classByName('W_Hourse'),     r: 7, c: 6,  color: 'white'},
                                 {db_id: 33,img: whiteRook,     Class: this.classByName('W_Rook'),       r: 7, c: 7,  color: 'white'}
                             ],      
                           ];
                  }
             } catch (error) {
                  return new ClientError(true, error.message, 'Game.setcharactersIndexes', error, this);
             
             }
             return this.charactersIndexes;


        }
            
        
        getTurnClass() {
           try {
             if (this.turnlist.length === this.turnClasses.length) {
                for (let tc=0; tc<this.turnClasses.length; tc++) {
                

                  const turnClass = this.turnClasses[tc];
                  const turnString = this.turn;
                  
                  const curentTurnString = this.turnlist[tc];
                   
                  if (
                       curentTurnString && turnString && turnClass.prototype instanceof Character &&
                       ( turnString === curentTurnString )
                     ) {
                     
                      return turnClass;
                     
                  }
                }
             }
            
             return new ClientError(true, "unable to get turn class", 'Game.getTurnClass', null, this);

           } catch (error) {alert(error.message);
                return new ClientError(true, error.message, 'Game.getTurnClass', error, this);
           }
        }
        getOtherTurn() {
                //copy
                const x = this.turnlist.slice(0);
                if (x.length >= 2) {
                        let lengthBeforeSplice = x.length;
                        x.splice(x.indexOf(this.turn), 1)[0];
                        let lengthAfterSplice = x.length;
                        //this.turnClasses
                        if (lengthBeforeSplice !== lengthAfterSplice) {
                                alert(this.turnlist.indexOf(x[0]) + 'me');
                                return x[0];
                        }
                }
                return false;
        }
        getOtherClass() {
                try {
                        const OtherTurn = this.getOtherTurn();
                        if (OtherTurn && this.turnlist.includes(OtherTurn) && this.turnlist.length === this.turnClasses.length) {
                                return this.turnClasses[this.turnlist.indexOf(OtherTurn)];
                        }
                } catch (error) {
                        return new ClientError(true, "stack error or unknown.", 'Game.getOtherClass', error, this);
                }
                return false;
        }
        switchTurn() {
                try {
                        var otherTurn = this.getOtherTurn();
                        if (otherTurn) {
                                this.turn = otherTurn;
                                this.turnClass = this.classByName(this.turn);
                        } else {
                                alert(otherTurn);
                                new ClientError(false, "Sorry Game system stop responding.", 'Game.switchTurn', null, this);
                        }
                } catch (error) {
                        //console.log('error from game.constructor', error);
                        new ClientError(true, "Sorry Game system stop responding.", 'Game.switchTurn', error, this);
                        throw error; // top game surely but recored and display message first nefpre stop js forced by throw error in catch
                }
        }
        /* setup and configure html and class based on player class, later in multplay only dislay 1msg container */
        setupClientMessages() {
           try {
               if (this.messageParent.length && this.messagesToggler) {
                  let success = true;
                  const fragment = document.createDocumentFragment();
                  this.turnClasses.forEach((turnClass) => {
                          let messagesString = '';
                          const className = 
                               (typeof(turnClass) === 'function' && turnClass.hasOwnProperty('name')) ? turnClass.name : 
                               (
                                   (
                                      typeof(turnClass) === 'function' && turnClass.hasOwnProperty('constructor') &&
                                      turnClass.constructor.hasOwnProperty('name')
                                    ) ? turnClass.constructor.name : false
                               );
                          if (className) {
                             
                              const messageElmNew = document.createElement("div");
                              messageElmNew.classList.add("container-fluid", "bg-white", "p-2");
                              messageElmNew.id = className.trim().toLowerCase();
                              fragment.appendChild(messageElmNew);
                              this.messageElements.push(messageElmNew);
                          } else {
                                  success = false;
                          }
                  });
                  
                  if (success === true) {
                          // add toggle effect
                          this.messagesToggler.on("click", (e)=>{
                            this.onToggleMessage(e);
                          });
                          // html core
                          this.messageParent.addClass("mb-2 mx-auto");
                          this.messageParent.addClass("p-2 bg-dark");
                          
                          this.messageParent.get(0).appendChild(fragment);
                          //this.messageParent.show('fast');
                          return success;
                  } else {
                          success = false;
                          return new ClientError(true, 'Unable to create Player Message Elment', 'Game.setupClientMessages', null, this);
                  }
               
               } else {
                 return new ClientError(true, 'Player Message Elements or toggler button Not Found', 'Game.setupClientMessages', null, this);
               }

           } catch (error) {
             return new ClientError(true, error.message, 'Game.setupClientMessages', error, this);
           }
        }
        
        
        BeforeMoveOn() {
                this.cJquery.on("click.beforeMove", (e) => {
                        this.onClickCanvas(e);
                });
        }
        BeforeMoveOff() {
                this.cJquery.off("click.beforeMove");
        }
        moveOn() {
                this.cJquery.on("click.move", (e) => {
                        this.onMoveClick(e);
                });
        }
        moveOff() {
                this.cJquery.off("click.move");
        }
        draw(data = []) {
                this.squares = this.setupSquares(data);
        }
        get validstart() {
                try {
                        if (
                                this.setup === true &&
                                Array.isArray(this.squares) && this.squares.length === 8
                        ) {
                                this._validstart = true;
                                let breakTop = false;
                                const allPieces = [
                                        B_King, B_Rook, B_Alfil, B_Queen, B_Hourse, B_Solider,
                                        W_King, W_Rook, W_Alfil, W_Queen, W_Hourse, W_Solider
                                ];
                                const invalidInstance = (piece) => {
                                        let validPieces = allPieces.filter((pieceClass) => {
                                                return (piece instanceof pieceClass) ? true : false;
                                        });
                                        return validPieces.length > 0;
                                };
                                for (let i = 0; i < this.squares.length; i++) {
                                        const row = this.squares[i];
                                        if (Array.isArray(row) && row.length === 8) {
                                                for (let s = 0; s < row.length; s++) {
                                                        const currentSquare = row[s];
                                                        if (!(currentSquare instanceof Square) ||
                                                                (
                                                                        currentSquare.holder &&
                                                                        !invalidInstance(currentSquare.holder)
                                                                )
                                                        )
                                                        {
                                                                this._validstart = false;
                                                                breakTop = true;
                                                                break;
                                                        }
                                                } /*noobuxprotect*/
                                        } else {
                                                this._validstart = false;
                                                break;
                                        }
                                        if (breakTop) {
                                                break;
                                        }
                                }
                        } else {
                                this._validstart = false;
                        }
                        return this._validstart;
                } catch (error) {
                        return new ClientError(true, "Unknown error B_King validstart", 'B_King.validstart', error, game);
                }
        }
        sx(reset = false) {
                if (reset) {
                        this.col = 0;
                        return false;
                }
                const sx = this.sWidth * this.col;
                this.col = (this.maxCol > this.col) ? this.col + 1 : 0;
                return sx;
        }
        sy(reset) {
                if (reset) {
                        this.row = 0;
                        return false;
                }
                const sy = this.sHeight * this.row;
                this.row += (this.maxRow > this.row) ? 1 : 0;
                return sy;
        }
        clearRect(xcoordinate_of_img1, ycoordinate_of_img1, img1_width, img1_height) {
                return this.context.clearRect(xcoordinate_of_img1, ycoordinate_of_img1, xcoordinate_of_img1 + img1_width, ycoordinate_of_img1 + img1_height);
        }
        setupSquares() {
                try {
                        const rows = [];
                        for (let r = 0; r < this.maxRow; r++) {
                                const row = [];
                                const sy = this.sHeight * r;
                                this.lastSquareColor = (this.lastSquareColor == 'white') ? 'khaki' : 'white';
                                //this.Childs.push();
                                for (let c = 0; c < this.maxCol; c++) {
                                        /*
                                        if (c>0){continue;}
                                        if(r>0){continue}
                                        */
                                        const sx = this.sWidth * c;
                                        const id = (c + 1) + (this.maxCol * (r));
                                        const db_id = this.charactersIndexes.length > r && this.charactersIndexes[r].length > c && this.charactersIndexes[r][c] && this.charactersIndexes[r][c].db_id ? this.charactersIndexes[r][c].db_id : null;
                                        const col = new Square(id, db_id, r, c, this.lastSquareColor, sx, sy, this.sWidth, this.sHeight, this.context, this);
                                        let currentCharacter = null;
                                        const chilObject = {
                                                square: col,
                                                holder: null
                                        };
                                        if (this.charactersIndexes.length > r && this.charactersIndexes[r].length > c && this.charactersIndexes[r][c]) {
                                                const char = this.charactersIndexes[r][c];
                                                currentCharacter = new char.Class(char.img, col, this.sWidth, this.sHeight, this.context, this);
                                                col.holder = currentCharacter;
                                        }
                                        this.lastSquareColor = (this.lastSquareColor == 'white') ? 'khaki' : 'white';
                                        row.push(col);
                                }
                                rows.push(row);
                        }
                        return rows;
                } catch (e) {
                        new ClientError(true, "error from Game.setupSquares", 'Game.setupSquares', e, this);
                }
        }
        setupImages() {
           try {
                 for (let i = 0; i < this.imagesIds.length; i++) {
                        const imageId = this.imagesIds[i];
                        if (imageId && $(`img#${imageId}`).length) {
                                this.images[imageId] = $(`img#${imageId}`).get(0);
                                this.maxImages -= 1;
                        } else {
                                break
                        }
                }
                if (this.maxImages === 0) {
                        return true;
                } else {
                        this.images = {};
                        return false;
                }
                return (this.maxImages === 0);
           } catch (error) {
                return new ClientError(true, error.message, 'Game.setupImages', error, this);
           }
        }
        setupSounds() {
                let success = false;
                try {
                        if (this.soundsIds.length === this.maxSounds) {
                                for (let i = 0; i < this.soundsIds.length; i++) {
                                        const audioElmId = this.soundsIds[i];
                                        if (audioElmId && $(`audio#${audioElmId}`).length) {
                                                this.sounds[audioElmId] = $(`audio#${audioElmId}`).get(0);
                                                success = true;
                                        } else {
                                                success = false;
                                                break;
                                        }
                                }
                        }
                        return success;
                } catch (error) {
                        return new ClientError(true, `Unable to load sound files: ${error.message}`, 'Game.setupSounds', error, this);
                }
        }
        getSquareByCords(x, y) {
                try {
                        let breaker = false;
                        let targetSquare = null;
                        if (!isNaN(parseInt(x)) && !isNaN(parseInt(x))) {
                                for (let r = 0; r < this.squares.length; r++) {
                                        if (breaker) {
                                                break;
                                        }
                                        const currentRow = this.squares[r];
                                        if (Array.isArray(currentRow)) {
                                                for (let i = 0; i < currentRow.length; i++) {
                                                        const currentSquare = currentRow[i];
                                                        if (currentSquare && !isNaN(parseInt(currentSquare.getX())) && !isNaN(parseInt(currentSquare.getY())) && !isNaN(parseInt(currentSquare.height)) && !isNaN(parseInt(currentSquare.width))) {
                                                                const sX = currentSquare.getX();
                                                                const sY = currentSquare.getY();
                                                                const sH = currentSquare.height;
                                                                const sW = currentSquare.width;
                                                                const fullW = sX + sW;
                                                                const fullH = sY + sH;
                                                                if ((x >= sX && x <= fullW) && (y >= sY && y <= fullH)) {
                                                                        targetSquare = currentSquare;
                                                                        breaker = true;
                                                                        break;
                                                                } else {
                                                                        //console.log(`invalid one X:${x} y:${y}, sX:${sX}, sY:${sY}, sW:${sW} , sH: ${sH}, fullW:${fullW}, fullH:${fullH}`); 
                                                                        continue;
                                                                }
                                                        } else {
                                                                targetSquare = null;
                                                                breaker = true;
                                                                break;
                                                        }
                                                }
                                        } else {
                                                console.log('found invalid row data Game.getSquareByCords');
                                                targetSquare = null;
                                                break;
                                        }
                                }
                        }
                        return targetSquare;
                } catch (e) {
                        // Excpetion as e raise e nested pased clientError auto created inhirted from throw new Error object
                        return new ClientError(true, e.message, 'Game.getSquareByCords', e, this);

                }
        }


        getMousePosition(clientX, clientY) {
                try {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = clientX - rect.left;
                        const y = clientY - rect.top;
                        return [x, y];
                } catch (error) {
                        return new ClientError(true, error.message, 'Game.getMousePosition', error, this);
                }
        }
        isValidMoveStart(square) {
                try {
                        /* db_id is recived from setup characterindex , and charcterindex will recived and async with server for validate */
                        return (typeof(square) === 'object' && square instanceof Square && this.validstart &&
                                square.db_id && square.holder instanceof Character &&
                                square.holder instanceof this.getTurnClass()) ? true : false;
                } catch (error) {
                        return new ClientError(true, error.message, 'Game.canIStartMove', error, this);
                }
        }
        isValidMovePiece(square) {
                try {
                // make sure all setup valid, and if holder piece on square make sure it instance of character, also validate it have the db id if peaice not random injected

                        return (typeof(square) === 'object' && square instanceof Square && this.validstart && !(square.holder && !square.holder instanceof Character) && !(square.holder && !square.db_id)) ? true : false;
                        
                        
                } catch (error) {
                        return new ClientError(true, error.message, 'Game.canIStartMove', error, this);
                }
        }
        
        canIStartKill(square) {
                try {
                        /* db_id is recived from setup characterindex , and charcterindex will recived and async with server for validate */
                        return (typeof(square) === 'object' && (square instanceof Square) && this.validstart) && square.db_id && square.holder instanceof Character && (square.holder instanceof this.getOtherClass()) ? true : false;
                } catch (error) {
                        //clicent message or sound based better or both, client message client unlike errorit have sound
                        return new ClientError(true, error.message, 'Game.canIStartKill', error, this);
                }
        }
        canIStartKill(square) {
                try {
                        /* db_id is recived from setup characterindex , and charcterindex will recived and async with server for validate */
                        return (typeof(square) === 'object' && (square instanceof Square) && this.validstart && !square.holder) ? true : false;
                } catch (error) {
                        return new ClientError(true, error.message, 'Game.canIStartKill', error, this);
                }
        }
        
        onClickCanvas(e) {
        
                /* This is first click event for start move piece if it your turn */
                try {
                        if (e && e.clientX && e.clientY) {
                                console.log(e.clientX);
                                const positions = this.getMousePosition(e.clientX, e.clientY);
                                const x = positions[0]
                                const y = positions[1];
                                const square = this.getSquareByCords(x, y);
                                const canIStartMove = this.isValidMoveStart(square);
                                if (canIStartMove === true) {
                                        this.startMove(square);
                                } else {
                                        return new ClientSoundMessage(this.turnClass, this.sounds['wrong_sound'], "You Can move only pieces.", 'info');
                                }
                                console.log(square, 'is it square?');
                        } else {
                                console.log("found invalid click Game.onClickCanvas");
                                return new ClientError(true, "invalid click event recived in start move action, issue with canvas and detect click position.", 'Game.onClickCanvas', null, this);
                        }
                } catch (error) {
                        return new ClientError(true, error.message, 'Game.onClickCanvas', error, this);
                }
        }
        
        //piece
        /* Here there are object on the square and is valid nest movement */
        startMove(square) {
                /* can add featue to check and validate if user try give invali new chess classs*/
                try {
                        const character = square.holder;
                        if (!character) {
                                // he try move empty square without pieace
                                return false;
                        }
                        if (character instanceof this.getOtherClass()) {
                                return alert("Its not your turn this ClientMessage Class needed");
                                //return new ClientError(false, "Its not your turn this ClientMessage Class", 'Game.startMove', null, this);
                        }
                        if (character && this.turn != this.getOtherTurn()) {
                                console.log(`Valid Move chess game Row: ${square.r}  Col: ${square.i}, id: ${square.id}`);
                                const moveOptions = character.getMoveOptions(square);
                                if (this.guideOn === true) {
                                        this.toggleGuide(moveOptions, 'show', this.iNoob);
                                }
                                console.log("moveOptions", moveOptions);
                                alert(this.turn);
                                // here temp stop 
                                this.BeforeMoveOff();
                                this.moveOn();
                        } else {
                                return new ClientError(false, "Its not your turn this ClientMessage Class Not error now make error", 'Game.startMove', null, this);
                        }
                } catch (error) {
                        console.log('Can not Move Unknown error from Error Game.startMove', error);
                        return new ClientError(false, "Can not Move.", 'Game.startMove', error, this);
                }
        }
        onMoveClick(e) {
                try {
                        if (e && e.clientX && e.clientY) {
                                console.log(e.clientX);
                                const positions = this.getMousePosition(e.clientX, e.clientY);
                                const x = positions[0]
                                const y = positions[1];
                                const square = this.getSquareByCords(x, y);
                                const canIStartMove = this.isValidMovePiece(square);
                                if (canIStartMove === true) {
                                        return this.moveController(square);
                                } else {
                                   return new ClientError(false, "You Can move only pieces.", 'Game.onMoveClick', null, this);
                                }
                                console.log(square, 'is it square?');
                        } else {
                                return new ClientError(true, "invalid click event recived in start move action, issue with canvas and detect click position.", 'Game.onMoveClick', null, this);
                        }
                } catch (error) {
                       return new ClientError(false, error.message, 'Game.onMoveClick', error, this);
                }
                
                
        }
        moveController(square) {
                try {
                        if (square instanceof Square && !(square.holder && !(square.holder instanceof Character))) {
                                const character = square.holder;
                                let isAttack = character && character instanceof Character ? true : false;

                                if (isAttack && !(character instanceof this.getOtherClass())) {
                                        return this.rejectMove(square, "Oh: You can not attack your ally its not bbug bomb feature ClientMessage Class needed");
                                }

                                if (this.turn === this.getOtherTurn()) {
                                        return this.rejectMove(square, "Oh this triky socket errro you can not move on other player turn");
                                }

                                if (isAttack) {
                                        this.attack(square);
                                        console.log("this can be attack or invalid action can preperae action methods and things and performance? is invalid:" + (isAttack && !(character instanceof this.getOtherClass())));
                                } else {
                                        // move
                                        this.attack(square);
                                        console.log("this can valid move or invalid move only can check now for distance must math and rules of class basednote this handle the solder to king can oop detected like if attack")
                                }
                                /* ############ ---- APPLY Switch on EndTurn CB atfer everything ---- ################# */
                                //this.switchTurn();
                                alert("Move phase:->" + this.turn);
                                /* phase 2 is last action can done before switch turn (last event cb) */
                                return true;
                        } else {
                                return new ClientError(false, "Unable to Move.", 'Game.Move', null, this);
                        }
                } catch (error) {
                        return new ClientError(false, error.message, 'Game.moveController', error, this);
                }
        }
        attack(square) {
                try {
                        alert(`handle attack:${square}`);
                } catch (error) {
                        return new ClientError(false, "Unable to Attack.", 'Game.Move', error, this);
                }
        }
        move(square) {
                try {
                        alert(`handle move:${square.db_id}`);
                } catch (error) {
                        return new ClientError(true, "Unable to Move the piece.", 'Game.Move', error, this);
                }
        }
        rejectMove(square, message) {
          try {
            return new ClientSoundMessage(this.turnClass, this.sounds['wrong_sound'], message, 'danger');
            
          } catch (error) {
            return new ClientError(true, error.message, 'Game.rejectMove', error, this);
          }
        }
        toggleGuide(moveOptions = [], status = 'show', noobModeOn = false) {
                if (status === 'show') {
                        //square.changeColor('limegreen');
                        moveOptions.greens.forEach((availSqaur) => {
                                availSqaur.changeColor('limegreen');
                        });
                        if (noobModeOn === true) {
                                moveOptions.killOptions.forEach((killOption) => {
                                        killOption.changeColor('red');
                                });
                        }
                } else {
                        moveOptions.greens.forEach((availSqaur) => {
                                availSqaur.changeColor();
                        });
                        if (noobModeOn === true) {
                                moveOptions.killOptions.forEach((killOption) => {
                                        killOption.changeColor();
                                });
                        }
                }
        }
        setCookie (cname, cvalue, exdays) {
           const d = new Date();
           d.setTime(d.getTime() + (exdays*24*60*60*1000));
           let expires = "expires="+ d.toUTCString();
           document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
        }
        getCookie (cname) {
           let name = cname + "=";
           let decodedCookie = decodeURIComponent(document.cookie);
           let ca = decodedCookie.split(';');
           for(let i = 0; i <ca.length; i++) {
             let c = ca[i];
             while (c.charAt(0) == ' ') {
               c = c.substring(1);
             }
             if (c.indexOf(name) == 0) {
               return c.substring(name.length, c.length);
             }
           }
           return "";
        }
        convertClassToName(theClass) {
                try {
                        let name = null;
                        if (typeof(theClass) === 'function' && theClass.hasOwnProperty('name') && theClass['name']) {
                                name = theClass.name;
                        } else if (
                                typeof(theClass) === 'function' && theClass.hasOwnProperty('constructor') &&
                                theClass['constructor'].hasOwnProperty('name') &&
                                theClass['constructor']['name']
                        ) {
                                name = theClass.constructor.name;
                        }
                        if (name && typeof(name) === 'string') {
                                return name;
                        } else {
                                return new ClientError(true, "Unable to convert class to Name.", 'Game.convertClassToName', error, this);
                        }
                } catch (error) {
                        return new ClientError(true, error.message, 'Game.convertClassToName', error, this);
                }
        }
        classByName(className) {
                try {
                        let targetClass = null;
                        for (let i = 0; i < this.classes.length; i++) {
                                const systemClassName = this.convertClassToName(this.classes[i]);
                                if (systemClassName && typeof(systemClassName) === 'string' &&  systemClassName.trim().toLowerCase() === className.trim().toLowerCase()) {
                                  
                                  targetClass = this.classes[i];
                                  break;
                                }
                                
                        }
                return targetClass;
                        
                } catch (error) {
                        return new ClientError(true, error.message, 'Game.classByName', error, this);
                }
        }
        
        getCharacterById(db_id) {
            try {
              let character = null;
              if (db_id) {
                const charactersIndexes = this.charactersIndexes;
                let breakParentLoop = false;
                for (let r=0; r<charactersIndexes.length; r++) {
                  if (breakParentLoop) {
                    break;
                  }
                  const charIndexObjArr = charactersIndexes[r];                  
                  for (let c=0; c<charIndexObjArr.length; c++) {
                    const charIndexObj = charIndexObjArr[c];
                    if (charIndexObj && typeof(charIndexObj) === 'object' && charIndexObj.hasOwnProperty('db_id') && charIndexObj['db_id'] && charIndexObj['db_id'] == db_id) {
                  
                      character = {id: charIndexObj.db_id, r: r, c: c, charIndexObj: charIndexObj};
                      breakParentLoop = true;
                      break;
                    }
                  }
                  
                  
                }
              }
              return character;
            } catch (error) {
              return new ClientError(true, error.message, 'Game.getCharacterById', error, this);
            }
        }
        moveCharacter(db_id, targetR, targetC) {
            try {
              let charToMove = getCharacterById(db_id);
              let completedI = 0;
              
              if (charToMove && db_id && !isNaN(parseInt(targetR)) && !isNaN(parseInt(targetC)) && !isNaN(parseInt(charToMove.r)) && !isNaN(parseInt(charToMove.c))) {
                targetR = parseInt(targetR);
                targetC = parseInt(targetC);
                
                currentR = parseInt(charToMove.r);
                currentC = parseInt(charToMove.c);
                
                const charIndexes = this.charactersIndexes;
                
                for (let r=0; r<charIndexes.length; r++) {
                  if (completedI == 2) {
                    break;
                  }
                  const charIndexObjArr = charIndexes[r];                  
                  for (let c=0; c<charIndexObjArr.length; c++) {
                    const charIndexObj = charIndexObjArr[c];
                    
                    if (r === currentR && c === currentC) {
                        // empty current char square that will move
                        charIndexObjArr[c] = null;
                        completedI += 1;
                    }
                    
                    
                    if (charIndexObj && typeof(charIndexObj) === 'object' && charIndexObj.hasOwnProperty('db_id') && charIndexObj['db_id'] && charIndexObj['db_id'] == db_id && targetR === r && targetC === c) {
                      // add the char removed to the new position 2d array
                      charIndexObjArr[c] = charToMove.charIndexObj;
                      completedI += 1;
                    }
                  }
                  
                  
                }
              }
              return completedI == 2;
            } catch (error) {
              return new ClientError(true, error.message, 'Game.getCharacterById', error, this);
            }
        }
        
        // rows and cells and content classes of cells and meta data of this class (secure unchangble list)
}
let game = null;
addEventListener("DOMContentLoaded", function() {
        // ultra secuirty mode remove game
        const game = (function(canvasId, main_error, imagesIds, soundsIds) {
                let gameObject = null;
                try {
                        if (canvasId && $(canvasId).length && Array.isArray(imagesIds) && Array.isArray(soundsIds)) {
                                gameObject = new Game(canvasId, main_error, imagesIds, soundsIds);
                        }
                } catch (error) {
                        const errorMsg = environment === 'publish' ? 'Unable to Load Game' : error.message;
                        return new ClientError(false, errorMsg, 'game.beforeConstruct', error, gameObject);
                }
                return gameObject;
        })("#demo", "#main_error", /*game static images*/
                [
                        "whiteSolder",
                        "blackSolder",
                        "whiteRook",
                        "blackRook",
                        "blackElephant",
                        "whiteElephant",
                        "whiteHourse",
                        "blackHourse",
                        "blackQueen",
                        "whiteQueen",
                        "blackKing",
                        "whiteKing",
                        "hourse_move_video",
                        "win_image"
                ], ['wrong_sound']);
        console.log(`is Game: ${game instanceof Game}`);
        console.log(`is ClientError: ${game instanceof ClientError}`);
        console.log(`is GameError or instance of GameError: ${game instanceof GameError}`, 'Game or Error like sqlalchemy oneOrNone but diffrent use oop convert way of work at end both same', game);
        console.log('\n' + ''.repeat(30), game, '\n' + '-'.repeat(30));
        //game.
        if (game instanceof GameError) {
                // error handle also can in constuct auto ajax report and socket disconect actions
                //alert((game instanceof ClientError && game instanceof GameError)+ ' is Client Error or Error and Game Error Handle Errors or report to server with GameError ajax \n\n While Not all GameErrors or clientErrors are inhirted like from Error class');
        }
});
</script>

</body>
</html>

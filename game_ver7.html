<!DOCTYPE html>
<html lang="en">
<head>
  <title>Bootstrap Example</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=merriweather">
      <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Rancho&effect=fire-animation">
        <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Rancho&effect=shadow-multiple|3d">
          <style>
            .must_hide {
              display: none !important;
            }
          </style>
</head>
<body>

 <img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpics.clipartpng.com%2Fmidle%2FPawn_White_Chess_Piece_PNG_Clip_Art-2751.png&f=1&nofb=1&ipt=686de2f1f2205ba0aa52a662ebd184b4b2e3f6de297c21add3740968d5b7bf2c&ipo=images" height="50" id="whiteSolder">
  <img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftoppng.com%2Fuploads%2Fthumbnail%2Fpawn-black-chess-piece-11532856202krihsmphdp.png&f=1&nofb=1&ipt=2bc3cbcc0c47b93dfb58aea0dca3a5f187cdcd3711ad3cd4842e3211a66eae7a&ipo=images" height="50" id="blackSolder">
   <img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpics.clipartpng.com%2FRook_White_Chess_Piece_PNG_Clip_Art-2754.png&f=1&nofb=1&ipt=40fbc49844b2df9922012b8e6c8a5b397b10a59530c1ece7bd5d835b355f8b6a&ipo=images" height="50" id="whiteRook">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fclipground.com%2Fimages%2Fchess-rook-clipart-6.png&f=1&nofb=1&ipt=3e3d33f4675f2e741961179e67762d9f322fb984aa32b47edd2d54b72917ed13&ipo=images" height="50" id="blackRook">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwebstockreview.net%2Fimages%2Fchess-clipart-svg-4.png&f=1&nofb=1&ipt=cecf360d4a6c1d60f0c8a2c9e6ad3f08f353a95d503dafa9f770f5d5b31c197e&ipo=images" height="50" id="blackElephant">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fimages.vexels.com%2Fmedia%2Fusers%2F3%2F254456%2Fisolated%2Fpreview%2Fd7a2f9afd47dbefcccd32dbae2f6a576-white-queen-chess-piece-color-stroke.png&f=1&nofb=1&ipt=923c5e3482b706fbde7069c254014ad78473f51cc779b4d7d7db68c8541839ef&ipo=images" height="50" id="whiteElephant">


<img src="https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fwww.geocities.ws%2Fismael%2Fwhite_horse.png&f=1&nofb=1&ipt=a39aed5baf99e8e1b191382b64abdfc8832ec15b98f49f317b4847e574da40a5&ipo=images" height="50" id="whiteHourse">


<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fclipartspub.com%2Fimages%2Fchess-pieces-clipart-knight-3.png&f=1&nofb=1&ipt=80568e167a9650e199226e49b48e749bae11b9db2f1c8b0e0fd33fcb3047bfe5&ipo=images" height="50" id="blackHourse">


<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fi.pinimg.com%2Foriginals%2F9b%2Fa0%2F27%2F9ba0277979c424fdb498efb66a7b140c.png&f=1&nofb=1&ipt=b919eadbb663c7e71fa621904674e4e951acb0761b4860d5a486d3cdab9177b8&ipo=images" height="50" id="blackQueen">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpics.clipartpng.com%2FQueen_White_Chess_Piece_PNG_Clip_Art-2757.png&f=1&nofb=1&ipt=15df4d77bddbe7d5c8f7eacf4b55df5c10b859780b4acb9e369f7fc49f87a09c&ipo=images" height="50" id="whiteQueen">


<img src="https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fcdn.shopify.com%2Fs%2Ffiles%2F1%2F2209%2F1363%2Fproducts%2Fadditional_megachess-44_33afb3f4-7bfe-4438-a46a-46b5d1b35078_1200x1200.png%3Fv%3D1535649501&f=1&nofb=1&ipt=09d270b3980618fd491cf36c7c524ac2072c82eee1d11d5cbc25fec7f1b438f0&ipo=images" height="50" id="blackKing">

<img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpics.clipartpng.com%2FQueen_White_Chess_Piece_PNG_Clip_Art-2757.png&f=1&nofb=1&ipt=15df4d77bddbe7d5c8f7eacf4b55df5c10b859780b4acb9e369f7fc49f87a09c&ipo=images" height="50" id="whiteKing" />


<div class="container-fluid">
    <div id="final_message" style="position: absolute;top: 0;left: 0;z-index: 100;width:100%;" class="d-flex jusitfy-content-center must_hide">
        <img id="win_image" src="https://media1.giphy.com/media/jsGz81YPCgw9YSliV0/giphy.gif" style="width:100%;" class="must_hide">
    </div>
    <div class="text-center" style="display:none;" id="main_error">
    </div>
    <div class="p-3 bg-dark mx-auto rounded d-flex justify-content-center align-items-center text-center" style="overflow:auto;background: chocolate;border: 4px solid chocolate;">
        <h1 class="font-effect-fire-animation" style="letter-spacing: 0.120rem;font-family: cursive;padding-top:7px;">multipleChess.com</h1>
    </div>
    <div class="bg-dark mx-auto rounded text-center" style="overflow:auto;max-height:780px;min-height:880px;border: 4px solid chocolate;">
        <canvas class="rounded border" id="demo" width="640" height="700">
            Your browser does not support the HTML canvas tag.
        </canvas>
        <div id="game_hiddens" class="container p-3 must_hide">
            <div id="client_error" class="must_hide">
            </div>
            <div id="screenConts" class="must_hide container-fluid w-100 p-0 border-rounded d-flex justify-content-center align-items-start" style="box-shadow: 6px 4px 10px 0 rgb(217 160 74), 4px 6px 20px 0 rgb(227 229 220 / 94%);max-width: 610px;display:none;">
                <img id="hourse_move_video" src="https://media0.giphy.com/media/wKdJy5gnLDb7ILmBu9/giphy.gif?cid=790b7611c7vhznfx69mvdleyy5ia10nvwtu43h7twlv6oh2y&ep=v1_gifs_search&rid=giphy.gif&ct=g" style="width:100%;object-fit:contain;max-width: 600px;" style="width:100%;display:none;" />
            </div>
        </div><!-- https://i.giphy.com/wKdJy5gnLDb7ILmBu9.webp -->
    </div>
</div>
<div>
</div>


<script>
// gameMessage
let environment = 'development';
class GameError {
    constructor(isSystem = false, errorMsg = "Unknown error", caller = 'Uknown', error = null, game = null, errorCb = () => {})
        {
            try {
                this.message = errorMsg ? errorMsg : 'Unknown error';
                //development
                this.environment = 'publish';
                this.isError = true;
                this.bsStatus = 'danger';
                this.bsStrong = 'Error: ';
                this.error = error;
                this.errorCb = errorCb;
                this.messageHTML = false;
                this.isSystem = isSystem;
                this.game = game;
                this.canvasElm = $("canvas#demo");
                this.messageElm = $("#client_error");
                this.gameHiddens = $("#game_hiddens");
                this.isJSError = (typeof(this.error) === 'object' && this.error instanceof Error && this.error.message) ? true : false;
                
                
                
                if (environment === 'publish'){
                  if (this.isJSError || this.isSystem) {
                     this.message = 'Game System Error!';
                  }                 
                  
                } else {
                  if (this.isJSError) {
                     this.message = this.error.message;
                  }
                }

                if (this.messageElm.length && this.canvasElm.length && this.messageElm.length && this.gameHiddens.length) {
                    this.messageHTML = true;
                }

            } catch (error) {
                game = game ? game : null;
                return new ClientError(true, "Unknown error while constructoring GameError", 'GameError.constructor', error, game);
            }
    }

    htmlErrorStart(errorHTML = '', message = null) {

        try {

            if (errorHTML && this.messageHTML === true && (this.bsStatus && typeof(this.bsStatus) === 'string') && (this.bsStrong && typeof(this.bsStrong) === 'string')) {
                this.canvasElm.hide();
                this.messageElm.removeClass("must_hide");
                this.messageElm.html(errorHTML);
                this.gameHiddens.removeClass("must_hide");
            } else {
                //alert(this.message);
            }
        } catch (error) {
            console.log('unknown error from GameError.htmlErrorStart', error);
        }
    }
    isValidErrorMsg() {
        return this.message && typeof(this.message) === 'string';
    }
    isValidError() {
        return this.error && typeof(this.error) === 'object' && this.error instanceof Error;
    }

    hideError() {
        try {
            this.messageElm.addClass("must_hide");
            this.gameHiddens.addClass("must_hide");
            this.canvasElm.show();
        } catch (error) {
            console.log('unknown error from GameError.hideError', error);
        }
    }
    throw() {
      throw 'System Error!';
    }

}

class ClientError extends GameError {
    constructor(isSystemMsg = false, errorMsg = "Unknown error", caller = 'Uknown', error = null, game = null, errorCb = () => {}) {
        const privateErrorCb = (typeof(errorCb) === 'function') ? errorCb : () => {};
        const privateCaller = (caller && typeof(caller) === 'string') ? caller : 'unknown method';
        // call the super class constructor and pass in the name parameter
        super(isSystemMsg, errorMsg, caller, error, game, errorCb);
        
        this.display = this.displayError();
    }
    getErrorTemplate() {
        return `
              <div class="alert alert-${this.bsStatus} alert-dismissible">
                    <button type="button" class="close" data-dismiss="alert">&times;</button>
                    <strong>${this.bsStrong}!</strong> ${this.message}
              </div>
                `;
    }

    displayError(errorCb) {

        try {
            if (this.isValidErrorMsg()) {
                this.htmlErrorStart(this.getErrorTemplate(), null);
            }

            if (this.isValidError()) {
                console.log(`error from ${this.caller}`, this.error);
            }

            /* optinal after error callback */
            if (typeof(this.errorCb) === 'function') {
                try {
                    return this.errorCb();
                } catch (error) {
                    console.log('unknown error from Calling the errorCb callback', error);
                }
            }

        } catch (error) {
            console.log('unknown error from GameError.displayError', error);
        }
        return false;
    }
}


class Character {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        this.img = img;
        this.sWidth = sWidth;
        this.sHeight = sHeight;
        
        this.square = square;
        this.sx = this.square.sx;
        this.sy = this.square.sy;
        
        this.ctx = ctx;
        this.game = game;
        this.width = (this.sWidth / 2);
        this.height = (this.sHeight / 1.5) + 2;
        // size of square - size of image
        this.remanierX = (this.sWidth - this.width);
        this.remanierY = (this.sHeight - this.height);

        // remaning/2 == (center) height and center width align-items-center justinfy-content-center (can have all)
        this.x = this.cascadeX();
        this.y = this.cascadeY();

        this.fullX = this.x + this.width;
        this.fullY = this.y + this.height;        
        this.draw(false);
    }
    /* cascade on update relationship in js as sqlalchemy */
    cascadeX() {
      return Math.max((this.remanierX/2), 0) + this.square.sx;
    }
    cascadeY() {
      return Math.max((this.remanierY/2), 0) + this.square.sy;
    }
    
    draw(isUpdate=true) {
        
        //this.ctx.beginPath();
        if (isUpdate) {
          /* clear old before draw if it update square also dynamic in kills replace*/
          this.square.empty();
        }        
        this.ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
        // this method achive best performance nothing more than needed. 

    }

    clearRect() {
        this.ctx.beginPath();
        this.ctx.clearRect(this.x, this.y, this.fullX, this.fullY);
        this.ctx.rect(this.x, this.y, this.fullX, this.fullY);
        this.ctx.fillStyle = this.color;
        this.ctx.fill();
        return true;
    }

    displayMovement(moveId, charClass) {
        if (moveId && $(`#${moveId}`).length && typeof(charClass) === 'object' && charClass instanceof this) {
            alert('hi yes');
        } else {
            alert("throw error invalid movment to typescript smuilate and testing client side while using the game.");
        }
    }    
    
}

class Black extends Character {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
        this.id = 1;
        this.winner = false;
        this.moves = 0;
        //socket related (setup onConnect event)
        this.ready = true;
        this.lastPlayTime = null;
        this.ready = true;
        this.kills = [];

        // user data
        this.color = 'khaki';
        this.name = 'unknown 1';
    }
    /* All squares Black Character can not Move in */
    getReds(targets) {
        try {
          const redTargets = [];
          for (let s=0; s<targets.length; s++) {
            const square = targets[s];
            if (typeof(square.holder) === 'object' && square.holder instanceof Black) {
              redTargets.push(square);
              console.log("there are ally stand here");
            }
          }
          return redTargets;
        } catch (error) {
          return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
        }
    }
    /* All squares Black Character can Move in */
    getGreens(targets) {
        try {
          const greenTargets = [];
          for (let s=0; s<targets.length; s++) {
            const square = targets[s];
            if ( !( (typeof(square.holder) === 'object' && square.holder instanceof Black)) ) {
              greenTargets.push(square);
              console.log("there its empty or enemy stand here");
            }
          }
          return greenTargets;
        } catch (error) {
          return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
        }
    }
    /* All squares White Character (enemy) stand on it */
    getTargets(targets) {
        try {
          const redTargets = [];
          for (let s=0; s<targets.length; s++) {
            const square = targets[s];
            if ( (typeof(square.holder) === 'object' && square.holder instanceof White) ) {
              redTargets.push(square);
              console.log("there its empty or enemy stand here");
            }
          }
          return redTargets;
        } catch (error) {
          return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
        }
    }

    /* used by bot / and begniner helight mode i like this mode myself (called also random play helped by OOP and Math and 2D Array */
    getMoveOptions(square) {
            const allowedSquares = this.getAll(square);
            const reds = this.getReds(allowedSquares);
            const greens = this.getGreens(allowedSquares);
            const killOptions = this.getTargets(allowedSquares);
            
            console.log('allowedSquares',allowedSquares);
            console.log('ally', reds);
            reds.forEach( (greenSquare)=>{
              greenSquare.color = 'green';
            });
            this.game.setupSquares();
            console.log('enemies', greens);
            console.log('kill Options', killOptions);
            return {
                allowedSquares, reds, greens, killOptions
              };
    }
}

class White extends Character {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
        this.id = 2;
        this.moves = 0;
        //socket related (setup onConnect event)
        this.ready = true;
        this.winner = false;
        this.lastPlayTime = null;
        this.someThingCalledDraw = false;
        this.kills = [];
        // user data
        this.color = 'white';
        this.name = 'unknown 2';

    }
    /* All squares White Character can not Move in */
    getReds(targets) {
        try {
          const redTargets = [];
          for (let s=0; s<targets.length; s++) {
            const square = targets[s];
            if (typeof(square.holder) === 'object' && square.holder instanceof White) {
              redTargets.push(square);
              console.log("there are ally stand here");
            }
          }
          return redTargets;
        } catch (error) {
          return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
        }
    }
    /* All squares White Character can Move in */
    getGreens(targets) {
        try {
          const greenTargets = [];
          for (let s=0; s<targets.length; s++) {
            const square = targets[s];
            if ( !(typeof(square.holder) === 'object' && square.holder instanceof White) ) {
              greenTargets.push(square);
              console.log("there its empty or enemy stand here");
            }
          }
          return greenTargets;
        } catch (error) {
          return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
        }
    }
    /* All squares Black Character (enemy) stand on it */
    getTargets(targets) {
        try {
          const redTargets = [];
          for (let s=0; s<targets.length; s++) {
            const square = targets[s];
            if ( (typeof(square.holder) === 'object' && square.holder instanceof Black) ) {
              redTargets.push(square);
              console.log("there its empty or enemy stand here");
            }
          }
          return redTargets;
        } catch (error) {
          return new ClientError(true, "Unknown error", 'B_King.getReds', error, this);
        }
    }
}


// this classes will dynamic extends one of 2 classes black or white
class B_Solider extends Black {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
    }
}

class B_King extends Black {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);

    }
    rightOne(square, check) {
      return (square.i < 8) && (square.i+1 === check.i) && (square.r === check.r);
    }
    leftOne(square, check) {
      return (square.i > 0) && (square.i-1 === check.i) && (square.r === check.r);
    }
    forwardOne(square, check) {
      return (square.r < 8) && (square.r+1 === check.r) && (square.i === check.i);
    }
    backOne(square, check) {
      return (square.r > 0) && (square.r-1 === check.r) && (square.i === check.i);
    }
    diagonallyForawrdRightOne(square, check) {
      return (square.r < 8) && (square.i < 8) && 
             ((square.r+1) === check.r) && ((square.i+1) === check.i);
    }
    
    diagonallyForawrdLeftOne(square, check) {
      return (square.r < 8) && (square.i > 0) && 
             ((square.r+1) === check.r) && ((square.i-1) === check.i);
    }
    diagonallyBackRightOne(square, check) {
      return (square.r > 0) && (square.i < 8) && 
             ((square.r-1) === check.r) && ((square.i+1) === check.i);
    }
    
    diagonallyBackLeftOne(square, check) {
      return (square.r > 0) && (square.i > 0) && 
             ((square.r-1) === check.r) && ((square.i-1) === check.i);
    }        
    getAll(square) {
        try {
            /* king can move around 3row between, 3cols right and 3 cols left */
            const targets = [];
            
            
            for (let r=0; r<this.game.squares.length; r++) {
              const rowArr = this.game.squares[r];
              for (let c=0; c<rowArr.length; c++) {
                const check = rowArr[c];
                

                   if ( this.rightOne(square, check) ) {
                   
                       targets.push(check);
                       
                   } else if ( this.leftOne(square, check) ) {
                   
                       targets.push(check);
                       
                   } else if ( this.forwardOne(square, check) ) {
                   
                       targets.push(check);
                       
                   } else if ( this.backOne(square, check) ) {
                   
                       targets.push(check);
                       
                   } else if ( this.diagonallyForawrdRightOne(square, check) ) {
                   
                       targets.push(check);
                       
                   }  else if ( this.diagonallyForawrdLeftOne(square, check) ) {
                   
                       targets.push(check);
                       
                   } else if ( this.diagonallyBackRightOne(square, check) ) {
                   
                       targets.push(check);
                       
                   } else if ( this.diagonallyBackLeftOne(square, check) ) {
                   
                       targets.push(check);
                   } else {
                     continue;
                   }

              }
            }
            return targets;
        } catch (error) {
           return new ClientError(true, "Unknown error", 'B_King.getAll', error, this);
        }
    }

}

class B_Queen extends Black {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
    }
}

class B_Hourse extends Black {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
        this.move = '#black_hourse_move';
        this.attack = '';
    }
}

class B_Alfil extends Black {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
    }
}

class B_Rook extends Black {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
    }
}



class W_Solider extends White {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
    }
}

class W_King extends White {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
    }
}

class W_Queen extends White {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
    }
}

class W_Hourse extends White {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
        this.move = '#black_hourse_move';
        this.attack = '';
    }
}

class W_Alfil extends White {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
    }
}

class W_Rook extends White {
    constructor(img, square, sWidth, sHeight, ctx, game) {
        super(img, square, sWidth, sHeight, ctx, game);
    }
}


class Square {
    constructor(id, r, i, color, sx, sy, sWidth, sHeight, ctx, game) {
        this.id = id;
        this.i = i;
        this.r = r;
        this.color = color;
        this.sx = sx;
        this.sy = sy;
        this.width = sWidth;
        this.height = sHeight;
        this.fullX = this.sx + this.width;
        this.fullY = this.sy + this.height;
        this.ctx = ctx;
        this.color = color;
        this.defaultColor = color;
        this.lineWidth = String(game.lineWidth);
        this.strokeStyle = game.strokeStyle;
        /* for clear why say css and border-box contains */
        this.borderTop = game.lineWidth;
        this.borderBottom = game.lineWidth;
        this.borderRight = game.lineWidth;
        this.borderLeft = game.lineWidth;
        
        this.holder = null;
        // sqlalchemy like relation, one to many, game has many squares. core
        this.game = game;
        this.draw();


    }
    setHolder(piece) {
        this.holder = piece;
    }
    draw() {

        this.ctx.beginPath();
        /* this inhirted from css, border 1px right, left, top, bottom border included within the element size
        */
        this.ctx.rect(
            this.sx + this.borderLeft, this.sy + this.borderTop, this.width - this.borderRight, this.height - this.borderBottom
            );
        
        this.ctx.lineWidth = this.lineWidth;
        this.ctx.strokeStyle = this.strokeStyle;
        
        this.ctx.stroke();
        
        this.ctx.fillStyle = this.color;
        this.ctx.fill();
        return true;
    }
    
    changeColor(color=null) {

        this.color = typeof(color) === 'string' ? color : this.defaultColor;
        this.draw();

        if (this.holder instanceof Character){
           this.holder.draw();
        }
    }
        
    clearRect() {
        return this.ctx.clearRect(this.x, this.y, this.fullX, this.fullY);
    }
    
    empty() {
        this.clearRect();
        this.draw();
        return true;
    }
    
    /* as this responsive desgin canvas must get dynamic x,y,h,w */
    getX() {
        let x = null;
        const squareWidth = this.width;

        if (!isNaN(parseInt(squareWidth)) && !isNaN(parseInt(this.i))) {
            // 7 considered gab or margin or test
            x = (squareWidth * this.i);
        } else {
            console.log("invalid square size data from Square.getX");
        }
        return x;
    }
    getY() {
        let y = null;
        const squareHeight = this.height;

        if (!isNaN(parseInt(squareHeight)) && !isNaN(parseInt(this.r))) {
            y = squareHeight * this.r;
        } else {
            console.log("invalid square size data from Square.getY");
        }
        return y;
    }
    

    //click() {}
}

//GameError
class Game {
    constructor(cElm, errorElm, imagesIds = []) {
        try {
            if (cElm && $(cElm).length && errorElm && $(errorElm).length && Array.isArray(imagesIds)) {
                this.imagesIds = imagesIds;

                this.images = {};
                this.squares = [];
                this.cJquery = $(cElm);
                this.canvas = this.cJquery.get(0);
                this.context = this.canvas.getContext("2d");
                this.boardContext = this.canvas.getContext("2d");
                this.turnlist = ['black', 'white'];
                this.turnClasses = [Black, White];
                this.turn = this.turnlist[Math.floor(Math.random()*this.turnlist.length)];
                this.turn = 'black';
                this.setup = false;
                this.maxImages = 14;
                this.imagesReady = this.setupImages();
                this.row = 0;
                this.col = 0;
                this.maxRow = 8;
                this.maxCol = 8;
                this.lineWidth = 1;
                this.strokeStyle = 'lightgray';
                this.sWidth = 80;
                this.sHeight = 100;
                this.lastSquareColor = 'white';
                this.guideOn = true;
                this.iNoob = true;

                // relation 
                this.Childs = [];

                const blackSolder = this.images['blackSolder'];
                const blackQueen = this.images['blackQueen'];
                const blackRook = this.images['blackRook'];
                const blackHourse = this.images['blackHourse'];
                const blackElephant = this.images['blackElephant'];
                const blackKing = this.images['blackKing'];

                const whiteSolder = this.images['whiteSolder'];
                const whiteQueen = this.images['whiteQueen'];
                const whiteRook = this.images['whiteRook'];
                const whiteHourse = this.images['whiteHourse'];
                const whiteElephant = this.images['whiteElephant'];
                const whiteKing = this.images['whiteKing'];

                this.charactersIndexes = [       
                    [/* row 1 */
                        {id: 1,img: blackRook,      Class: B_Rook,       r: 0, c: 0,  color: 'black'},
                        {id: 2,img: blackHourse,    Class: B_Hourse,     r: 0, c: 1,  color: 'black'},
                        {id: 3,img: blackElephant,  Class: B_Alfil,      r: 0, c: 2,  color: 'black'},
                        {id: 4,img: blackQueen,     Class: B_Queen,      r: 0, c: 3,  color: 'black'},
                        null,
                        {id: 6,img: blackElephant,  Class: B_Alfil,      r: 0, c: 5,  color: 'black'},
                        {id: 7,img: blackHourse,    Class: B_Hourse,     r: 0, c: 6,  color: 'black'},
                        {id: 8,img: blackRook,      Class: B_Rook,       r: 0, c: 7,  color: 'black'}
                    ],
                    [
                        /* row 2 */
                        {id: 9,img: blackSolder,    Class: B_Solider,    r: 1, c: 0,  color: 'black'},
                        {id: 10,img: blackSolder,    Class: B_Solider,    r: 1, c: 1,  color: 'black'},
                        {id: 11,img: blackSolder,    Class: B_Solider,    r: 1, c: 2,  color: 'black'},
                        {id: 12,img: blackSolder,    Class: B_Solider,    r: 1, c: 3,  color: 'black'},
                        {id: 13,img: blackSolder,    Class: B_Solider,    r: 1, c: 4,  color: 'black'},
                        {id: 14,img: blackSolder,    Class: B_Solider,    r: 1, c: 5,  color: 'black'},
                        {id: 15,img: blackSolder,    Class: B_Solider,    r: 1, c: 6,  color: 'black'},
                        {id: 16,img: blackSolder,    Class: B_Solider,    r: 1, c: 7,  color: 'black'}
                    ],

                    [null, {id: 5,img: blackKing,      Class: B_King,       r: 2, c:2,  color: 'black'}, null], /* row 3 */
                    [], /* row 4 */
                    [], /* row 5 */
                    [], /* row 6 */

                    [   /* row 7 */
                        { id: 17,img: whiteSolder,   Class: W_Solider,    r: 6, c: 0,  color: 'white'},
                        { id: 18,img: whiteSolder,   Class: W_Solider,    r: 6, c: 1,  color: 'white'},
                        { id: 29,img: whiteSolder,   Class: W_Solider,    r: 6, c: 2,  color: 'white'},
                        { id: 20,img: whiteSolder,   Class: W_Solider,    r: 6, c: 3,  color: 'white'},
                        { id: 21,img: whiteSolder,   Class: W_Solider,    r: 6, c: 4,  color: 'white'},
                        { id: 22,img: whiteSolder,   Class: W_Solider,    r: 6, c: 5,  color: 'white'},
                        { id: 23,img: whiteSolder,   Class: W_Solider,    r: 6, c: 6,  color: 'white'},
                        { id: 24,img: whiteSolder,   Class: W_Solider,    r: 6, c: 7,  color: 'white'}
                    ],


                    [   /* row  8 */
                        { id: 26,img: whiteRook,     Class: W_Rook,       r: 7, c: 0,      color: 'white'},
                        { id: 27,img: whiteHourse,   Class: W_Hourse,     r: 7, c: 1,      color: 'white'},
                        { id: 28,img: whiteElephant, Class: W_Alfil,      r: 7, c: 2,      color: 'white'},
                        { id: 29,img: whiteQueen,    Class: W_Queen,      r: 7, c: 3,      color: 'white'},
                        { id: 30,img: whiteKing,     Class: W_King,       r: 7, c: 4,      color: 'white'},
                        { id: 31,img: whiteElephant, Class: W_Alfil,      r: 7, c: 5,      color: 'white'},
                        { id: 32,img: whiteHourse,   Class: W_Hourse,     r: 7, c: 6,      color: 'white'},
                        { id: 33,img: whiteRook,     Class: W_Rook,       r: 7, c: 7,      color: 'white'}
                    ],
                ];
                
                /* Load Private Start */
                const load = ()=>{
                  if (this.imagesReady) {
                      // Change the globalCompositeOperation to destination-over so that anything
                      // that is drawn on to the canvas from this point on is drawn at the back
                      // of what's already on the canvas
                      //this.context.globalCompositeOperation = 'destination-over';
                      this.draw();
                      console.log('squares', this.squares);
                      
                      if (this.squares.length === 8) {
                          // events and logic of game
                          this.BeforeMoveOn();
                          return true;

                      } else {
                          return new ClientError(true, "Error Unable to setup squares", 'Game.constructor', null, this);
                      }

                  } else {
                      return new ClientError(true, "Error Canvas Missing or invalid images provided", 'Game.constructor', null, this);
                  }
                };

                this.setup = load();

            } else {
                return new ClientError(true, "Error Canvas not constructed successfully", 'Game.constructor', null, this);
            }
            
            
        } catch (error) {
            //console.log('error from game.constructor', error);
            new ClientError(true, "Unknown Error", 'Game.constructor', error, this);
            throw error;
        }
    }
    
    getOtherTurn() {
        //copy
        const x = this.turnlist.slice(0);
        if (x.length >= 2) {
              let lengthBeforeSplice = x.length;
              x.splice(x.indexOf(this.turn),1)[0];
              let lengthAfterSplice = x.length;
              
              //this.turnClasses
              if (lengthBeforeSplice !== lengthAfterSplice) {
                 alert(this.turnlist.indexOf(x[0]) + 'me');
                 return x[0];
              }
        }
        return false;
    }
    getOtherClass() {
      try {
              const OtherTurn = this.getOtherTurn();
        if (OtherTurn && this.turnlist.includes(OtherTurn) && this.turnlist.length === this.turnClasses.length) {
            return this.turnClasses[this.turnlist.indexOf(OtherTurn)];
        }
      } catch (error) {
      new ClientError(true, "stack error or unknown.", 'Game.getOtherClass', error, this);

              
      }
      return false;
    }
    
    
    
    switchTurn() {
    try {

              var otherTurn = this.getOtherTurn();

              if (otherTurn) {
              
                this.turn = otherTurn;
                
              } else {
                             
alert(otherTurn);
                new ClientError(false, "Sorry Game system stop responding.", 'Game.switchTurn', null, this);
              }
    }  catch (error) {
            //console.log('error from game.constructor', error);
            new ClientError(true, "Sorry Game system stop responding.", 'Game.switchTurn', error, this);
            throw error; // top game surely but recored and display message first nefpre stop js forced by throw error in catch
        }

    }
    BeforeMoveOn() {
       this.cJquery.on("click.beforeMove", (e) => {
           this.onClickCanvas(e);
       });
    }
    BeforeMoveOff() {
       this.cJquery.off("click.beforeMove");
    }
    
    moveOn() {
       this.cJquery.on("click.move", (e) => {
           this.onMove(e);
       });
    }
    moveOff() {
       this.cJquery.off("click.move");
    }
    
    draw(data=[]) {
        this.squares = this.setupSquares(data);
    }


    get validstart() {
      try {
           if ( 
                 this.setup === true && 
                Array.isArray(this.squares) && this.squares.length  === 8
             ) {
              
              this._validstart = true;
              let breakTop = false;
              
              const allPieces = [
                    B_King, B_Rook, B_Alfil, B_Queen, B_Hourse, B_Solider,
                    W_King, W_Rook, W_Alfil, W_Queen, W_Hourse, W_Solider
                 ];
                 
              const invalidInstance = (piece)=>{
                let validPieces = allPieces.filter( (pieceClass)=>{
                  return (piece instanceof pieceClass) ? true : false;
                });
                return validPieces.length > 0;
              };
              
              
              for (let i=0; i<this.squares.length; i++) {
                const row = this.squares[i];
                if ( Array.isArray(row) && row.length === 8 ) {
                 for (let s=0; s<row.length; s++){
                 const currentSquare = row[s];
                 if ( !( currentSquare instanceof Square ) ||
                      ( 
                        currentSquare.holder && 
                        !invalidInstance(currentSquare.holder)
                      ) 
                   )
              {
                this._validstart = false;
                breakTop = true;
                break;
              }
 
                }/*noobuxprotect*/
                } else {
                  this._validstart = false;
                  break;
                }
                
                if (breakTop) {
                  break;
                }
                

            }   
          } else {
              this._validstart = false;
          }
          return this._validstart;
      } catch (error) {
          return new ClientError(true, "Unknown error B_King validstart", 'B_King.validstart', error, game);
      }
           
    }


    sx(reset = false) {
        if (reset) {
            this.col = 0;
            return false;
        }
        const sx = this.sWidth * this.col;
        this.col = (this.maxCol > this.col) ? this.col + 1 : 0;
        return sx;
    }
    sy(reset) {
        if (reset) {
            this.row = 0;
            return false;
        }

        const sy = this.sHeight * this.row;
        this.row += (this.maxRow > this.row) ? 1 : 0;
        return sy;
    }

    clearRect(xcoordinate_of_img1, ycoordinate_of_img1, img1_width, img1_height) {
        return this.context.clearRect(xcoordinate_of_img1, ycoordinate_of_img1, xcoordinate_of_img1 + img1_width, ycoordinate_of_img1 + img1_height);

    }
    setupSquares() {

       try {

        
        const rows = [];
        for (let r = 0; r < this.maxRow; r++) {
            const row = [];
            const sy = this.sHeight * r;
            this.lastSquareColor = (this.lastSquareColor == 'white') ? 'khaki' : 'white';
            //this.Childs.push();
            for (let c = 0; c < this.maxCol; c++) {

/*
if (c>0){continue;}
if(r>0){continue}
*/

                const sx = this.sWidth * c;
                const id = (c + 1) + (this.maxCol * (r));
                const col = new Square(id, r, c, this.lastSquareColor, sx, sy, this.sWidth, this.sHeight, this.context, this);
                let currentCharacter = null;
                const chilObject = {
                    square: col,
                    holder: null
                };

                if (this.charactersIndexes.length > r && this.charactersIndexes[r].length > c && this.charactersIndexes[r][c]) {
                    const char = this.charactersIndexes[r][c];

                    currentCharacter = new char.Class(char.img, col, this.sWidth, this.sHeight, this.context, this);
                    col.holder = currentCharacter;

                }


                this.lastSquareColor = (this.lastSquareColor == 'white') ? 'khaki' : 'white';
                row.push(col);
            }
            rows.push(row);
        }

        return rows;
        
       } catch (e) {
          new ClientError(true, "error from Game.setupSquares", 'Game.setupSquares', e, this);
       }
    }
    
    
    setupImages() {
        for (let i = 0; i < this.imagesIds.length; i++) {
            const imageId = this.imagesIds[i];
            if (imageId && $(`#${imageId}`).length) {
                this.images[imageId] = $(`#${imageId}`).get(0);
                this.maxImages -= 1;
            } else {
                break
            }
        }
        if (this.maxImages === 0) {
            return true;
        } else {
            this.images = {};
            return false;
        }
        return (this.maxImages === 0);
    }

   getSquareByCords(x, y) {
   
      try {
              let breaker = false;
        let targetSquare = null;
        if (!isNaN(parseInt(x)) && !isNaN(parseInt(x))) {
            for (let r = 0; r < this.squares.length; r++) {
                if (breaker) {
                    break;
                }
                const currentRow = this.squares[r];
                if (Array.isArray(currentRow)) {
                    for (let i = 0; i < currentRow.length; i++) {

                        const currentSquare = currentRow[i];
                        if (currentSquare && !isNaN(parseInt(currentSquare.getX())) && !isNaN(parseInt(currentSquare.getY())) && !isNaN(parseInt(currentSquare.height)) && !isNaN(parseInt(currentSquare.width))) {

                            const sX = currentSquare.getX();
                            const sY = currentSquare.getY();
                            const sH = currentSquare.height;
                            const sW = currentSquare.width;

                            const fullW = sX + sW;
                            const fullH = sY + sH;

                            if ((x >= sX && x <= fullW) && (y >= sY && y <= fullH)) {
                                targetSquare = currentSquare;
                                breaker = true;
                                break;
                            } else {

                                //console.log(`invalid one X:${x} y:${y}, sX:${sX}, sY:${sY}, sW:${sW} , sH: ${sH}, fullW:${fullW}, fullH:${fullH}`); 

                                continue;
                            }
                        } else {

                            targetSquare = null;
                            breaker = true;
                            break;
                        }
                    }
                } else {
                    console.log('found invalid row data Game.getSquareByCords');
                    targetSquare = null;
                    break;
                }
            }
        }
        
        return targetSquare;
      } catch (e) {
         // Excpetion as e raise e nested pased clientError auto created inhirted from throw new Error object
         throw e;
      }
}

    

    getMousePosition(clientX, clientY) {
    
        const rect = this.canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        return [x, y];
    }
    onClickCanvas(e) {
        if (e && e.clientX && e.clientY) {
        console.log(e.clientX);

            const positions = this.getMousePosition(e.clientX, e.clientY);
            const x = positions[0]
            const y = positions[1];

            const square = this.getSquareByCords(x, y);
            
            

            const canIStartMove = this.canIStartMove(square);
            if (canIStartMove === true) {
                this.startMove(square);                
            } else {
                //return new ClientError(false, "Can not Move.", 'Game.startMove', null, this);
            }


            console.log(square, 'is it square?');
        } else {
            console.log("found invalid click Game.onClickCanvas");
        }
    }    
    canIStartMove(square) {
        try {
            return (typeof(square) === 'object' && (square instanceof Square) && this.validstart) ? true : false;
        } catch (error) {
            return false;
        }
    }
//piece

    /* Here there are object on the square and is valid nest movement */
    startMove(square) {/* can add featue to check and validate if user try give invali new chess classs*/
        try {
        
        const character = square.holder;
        if (!character){
          // he try move empty square without pieace
          return false;
        }
        if (character instanceof this.getOtherClass()){
          return alert("Its not your turn this ClientMessage Class needed");
        
          //return new ClientError(false, "Its not your turn this ClientMessage Class", 'Game.startMove', null, this);
        }


            if ( character && this.turn != this.getOtherTurn() ) {
                 
                 console.log(`Valid Move chess game Row: ${square.r}  Col: ${square.i}, id: ${square.id}`);

                 
                    const moveOptions = character.getMoveOptions(square);
                    if ( this.guideOn === true ) {
     
                      this.toggleGuide(moveOptions, 'show', this.iNoob);
                    }
                    
                    console.log("moveOptions", moveOptions);
                    alert(this.turn);
                    
                    // here temp stop 
                    this.BeforeMoveOff();
                    this.moveOn();
     

            } else {
               return new ClientError(false, "Its not your turn this ClientMessage Class Not error now make error", 'Game.startMove', null, this);
            }

            
        } catch (error) {
            console.log('Can not Move Unknown error from Error Game.startMove', error);

            return new ClientError(false, "Can not Move.", 'Game.startMove', error, this);
        }
    }
    
    onMove(e) {
        if (e && e.clientX && e.clientY) {
            this.switchTurn();
            alert("Move phase:->"+this.turn);
            /* phase 2 is last action can done before switch turn (last event cb) */
            return true;
        } else {
           return new ClientError(false, "Unable to apply the next move.", 'Game.onMove', null, this);
        }

    }
    
    toggleGuide(moveOptions=[], status='show', noobModeOn=false) {
       if (status === 'show') {
       
         //square.changeColor('limegreen');
         moveOptions.greens.forEach((availSqaur)=>{
            availSqaur.changeColor('limegreen');
         });
         
         if ( noobModeOn === true ) {
            moveOptions.killOptions.forEach((killOption)=>{
                killOption.changeColor('red');
            });
         }
         
       } else {
          moveOptions.greens.forEach((availSqaur)=>{
            availSqaur.changeColor();
         });
         
         if ( noobModeOn === true ) {
            moveOptions.killOptions.forEach((killOption)=>{
                killOption.changeColor();
            });
         }
       }
    }
    
}


let game = null;
addEventListener("DOMContentLoaded", function() {
        // ultra secuirty mode remove game
    const game = (function(canvasId, main_error, imagesIds) {
        let gameObject = null;
        try {
            if (canvasId && $(canvasId).length && Array.isArray(imagesIds)) {
                gameObject = new Game(canvasId, main_error, imagesIds);
            }
        } catch (error) {
            const errorMsg = environment === 'publish' ? 'Unable to Load Game' : error.message;
            return new ClientError(false, errorMsg, 'game.beforeConstruct', () => {}, gameObject);
        }
        return gameObject;
    })("#demo", "#main_error", /*game static images*/
      [
        "whiteSolder",
        "blackSolder",
        "whiteRook",
        "blackRook",
        "blackElephant",
        "whiteElephant",
        "whiteHourse",
        "blackHourse",
        "blackQueen",
        "whiteQueen",
        "blackKing",
        "whiteKing",
        "hourse_move_video",
        "win_image"
    ]);

    console.log(`is Game: ${game instanceof Game}`);
    console.log(`is ClientError: ${game instanceof ClientError}`);
    console.log(`is GameError or instance of GameError: ${game instanceof GameError}`, 'Game or Error like sqlalchemy oneOrNone but diffrent use oop convert way of work at end both same', game);
    console.log('\n'+''.repeat(30), game, '\n'+'-'.repeat(30));

//game.
if (game instanceof GameError){

// error handle also can in constuct auto ajax report and socket disconect actions
//alert((game instanceof ClientError && game instanceof GameError)+ ' is Client Error or Error and Game Error Handle Errors or report to server with GameError ajax \n\n While Not all GameErrors or clientErrors are inhirted like from Error class');
}

});




</script>

</body>
</html>
